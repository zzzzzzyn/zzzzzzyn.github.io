<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Loki</title>
  
  <subtitle>弱鸡一枚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zzzzzzyn.github.io/"/>
  <updated>2020-09-13T10:14:12.232Z</updated>
  <id>http://zzzzzzyn.github.io/</id>
  
  <author>
    <name>Loki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>诡计博物馆</title>
    <link href="http://zzzzzzyn.github.io/2020/09/13/%E8%AF%A1%E8%AE%A1%E5%8D%9A%E7%89%A9%E9%A6%86/"/>
    <id>http://zzzzzzyn.github.io/2020/09/13/诡计博物馆/</id>
    <published>2020-09-13T09:29:44.000Z</published>
    <updated>2020-09-13T10:14:12.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="复仇日记"><a href="#复仇日记" class="headerlink" title="复仇日记"></a>复仇日记</h3><p>痴心人甘愿落于人后，皆因奉心上人事事为先</p><p>人是一种无法忍受无意义的生物，如果察觉到自己的行为是无意义的，就会想方设法地赋予它意义，或者对其无意义的行为持有疑问 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;复仇日记&quot;&gt;&lt;a href=&quot;#复仇日记&quot; class=&quot;headerlink&quot; title=&quot;复仇日记&quot;&gt;&lt;/a&gt;复仇日记&lt;/h3&gt;&lt;p&gt;痴心人甘愿落于人后，皆因奉心上人事事为先&lt;/p&gt;
&lt;p&gt;人是一种无法忍受无意义的生物，如果察觉到自己的行为是无意义的，就会想
      
    
    </summary>
    
    
    
      <category term="书" scheme="http://zzzzzzyn.github.io/tags/%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap笔记</title>
    <link href="http://zzzzzzyn.github.io/2020/06/06/ConcurrentHashMap%E7%AC%94%E8%AE%B0(JDK1.8)/"/>
    <id>http://zzzzzzyn.github.io/2020/06/06/ConcurrentHashMap笔记(JDK1.8)/</id>
    <published>2020-06-06T03:37:22.000Z</published>
    <updated>2020-06-06T04:24:43.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><code>ConcurrentHashMap</code>是并发版本的<code>HashMap</code>，没有线程安全问题，在JDK1.8中使用<strong>CAS+synchronized</strong>来做并发安全保证，在结构上基本和<code>HashMap</code>的结构相同，也是<strong>数组+链表+红黑树</strong>的结构。</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h3><h4 id="2-1-插入"><a href="#2-1-插入" class="headerlink" title="2.1 插入"></a>2.1 插入</h4><p>插入方法是使用最频繁的方法，就是你想的那样，插入或者替换两种情况，大致流程都写在了代码中。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1. 计算key的hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 2. 是否需要进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 3. tab[i]位置的node是否为null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.1 cas方式插入新node</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 是否正在扩容，帮助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 5. 插入或替换</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 判断fh是node链头节点还是红黑树根节点？</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历node链，通过key决定替换还是尾部插入</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">// 替换</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 插入</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 插入红黑树</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断node链是否需要树化（链表循环时记录了binCount）</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>计算出key的hash值，并进入最外层的大循环。</li><li>判断<strong>table是否需要初始化</strong>，需要进行初始化并再次进入循环，不需要则进入下一步。</li><li>通过hash得到索引下标，<strong>判断有无Node(链表或红黑树)</strong>，<strong>没有则将kv以CAS方式插入</strong>(作为链表首节点)到此坐标位置，并退出循环增加计数返回、否则进入下一步。</li><li><strong>table是否正在扩容</strong>，是则帮助扩容并再次进入循环，否则进入下一步。</li><li>对hash得到的下标的元素，判断插入还是替换。如果是链表，添加完成后判断是否需要树化</li><li>如果是插入则执行<code>addCount()</code>增加计数，否则不增加。</li></ol></blockquote><img src="https://img-blog.csdnimg.cn/20200304105815523.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><h4 id="2-2-插入操作依赖的一些方法"><a href="#2-2-插入操作依赖的一些方法" class="headerlink" title="2.2 插入操作依赖的一些方法"></a>2.2 插入操作依赖的一些方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新哈希，减少哈希冲突</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// table初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// table是否需要初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. sc&lt;0表示正在调整table大小</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// sc&lt;0说明有其他线程正在执行扩容或初始化，本线程暂停</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 2. CAS设置sizeCTL的值为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 确认此时table没有被其他线程初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 确定table容量</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// sc为n-n/4，也就是n的3/4</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// sizeCtl为下次扩容阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加计数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check&gt;=0说明需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转移方法 有空回来填坑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 帮助转移</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-获取"><a href="#2-3-获取" class="headerlink" title="2.3 获取"></a>2.3 获取</h4><p>获取操作相对插入而言肯定会简单一些，分为三个步骤：</p><ol><li>获取key对应的hash值，并判断对应下标出的node不为空，若node与传入key相等，返回对应value。</li><li>通过eh判断table是否正在扩容，遍历扩容处的链表上是否存在对应key，返回对应value或null。</li><li>既不是头结点也没有扩容，遍历对应链表，若存在相应key，返回value否则返回null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 1. 获取key的hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 2. 判断链表不为空且对应下标处node不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1 判断hash是否相等 </span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2 eh&lt;0表示正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 2.3 遍历链表查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. key不存在，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            K ek;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-HashMap和ConcurrentHashMap的区别"><a href="#3-HashMap和ConcurrentHashMap的区别" class="headerlink" title="3. HashMap和ConcurrentHashMap的区别"></a>3. HashMap和ConcurrentHashMap的区别</h3><ul><li><code>HashMap</code>线程不安全，数组+链表+红黑树实现，key可为null</li><li><code>ConcurrentHashMap</code>线程安全，CAS+synchronized和数组+链表+红黑树实现，key不能为null</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p><code>ConcurrentHashMap</code>是并发安全情况下的选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;是并发版本的&lt;code&gt;HashMap&lt;/code&gt;，没有线程安全问题，在JDK1.8中使用&lt;strong&gt;CAS+synchronized&lt;/strong&gt;来做并发安全保证，在结构上基本和&lt;code&gt;HashMap&lt;/code&gt;的结构相同，也是&lt;strong&gt;数组+链表+红黑树&lt;/strong&gt;的结构。&lt;/p&gt;
&lt;h3 id=&quot;2-源码解析&quot;&gt;&lt;a href=&quot;#2-源码解析&quot; class=&quot;headerlink&quot; title=&quot;2. 源码解析&quot;&gt;&lt;/a&gt;2. 源码解析&lt;/h3&gt;&lt;h4 id=&quot;2-1-插入&quot;&gt;&lt;a href=&quot;#2-1-插入&quot; class=&quot;headerlink&quot; title=&quot;2.1 插入&quot;&gt;&lt;/a&gt;2.1 插入&lt;/h4&gt;&lt;p&gt;插入方法是使用最频繁的方法，就是你想的那样，插入或者替换两种情况，大致流程都写在了代码中。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="集合框架" scheme="http://zzzzzzyn.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>重新认识String</title>
    <link href="http://zzzzzzyn.github.io/2020/05/29/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86String/"/>
    <id>http://zzzzzzyn.github.io/2020/05/29/重新认识String/</id>
    <published>2020-05-29T13:06:54.000Z</published>
    <updated>2020-05-30T00:51:22.229Z</updated>
    
    <content type="html"><![CDATA[<p><code>String</code>是大三刚学<code>Java</code>的时候接触的，以前看<code>String</code>的时候感觉很简单，感觉会用就行了，后来发现用的时候也会有很多问题，所以回来温习一下</p><a id="more"></a><h4 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h4><p>下面是<code>String</code>源码中的所有属性，我们可以看出：</p><ul><li><code>String</code>是<code>final</code>修饰的，所以<code>String</code>中的所有方法也都被<code>final</code>修饰，类不能被继承，方法不能被重写。这也和我们面试题中看到的一致</li><li><code>String</code>最重要的属性是<code>value[]</code>，用来存储字符串，它是一个定长的char数组，一经赋值不可修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-常用的方法"><a href="#2-常用的方法" class="headerlink" title="2. 常用的方法"></a>2. 常用的方法</h4><p>下面这些方法中：</p><ul><li><code>equals</code>被<code>String</code>重写了，先比较内存地址再比较字符数组</li><li><code>substring</code>和<code>concat</code>都返回一个新的<code>String</code>，因为<code>String</code>是<code>final</code>修饰，无法被修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先比较内存地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 比较字符数组</span></span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 截取长度</span></span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="comment">// 扩充字符数组容量</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    <span class="comment">// 放入到buf中</span></span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：任何修改String的操作，都只会返回新对象，不会对原来的对象有影响</strong></p><h4 id="3-String与常量池"><a href="#3-String与常量池" class="headerlink" title="3. String与常量池"></a>3. String与常量池</h4><p><strong>字符串常量池存在于堆中(jdk1.8)，Jvm为了提高性能而使用常量池，每次创建字符串对象时，都会在字符串常量池中存一份(如果里边没有的话)。</strong></p><p>使用常量池的几种情况：</p><ul><li>双引号赋值</li><li><code>String</code>类的<code>intern</code>方法</li><li><code>new String(&quot;abc&quot;)</code>，abc不在常量池中时，会现在常量池中创建，然后在堆中创建一份<code>String</code>对象</li></ul><h4 id="4-字符串的拼接与比较"><a href="#4-字符串的拼接与比较" class="headerlink" title="4. 字符串的拼接与比较"></a>4. 字符串的拼接与比较</h4><h5 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"ab"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>str1</code>在常量池中创建，<code>str2</code>先检查常量池中有无字符串<code>ab</code>，没有就在常量池中创建，然后去堆中创建对象并把地址复制给<code>str2</code>，所以他们的内存地址比较为<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>str1</code>和<code>str2</code>比较内存地址，返回<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">String str2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面为什么会返回<code>true</code>？因为编译器对<code>str1</code>进行了编译期优化，将<code>String str1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;</code>优化成了<code>String str1 = &quot;abc&quot;</code>，又因为字符串常量池的存在，所以<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="string">"ab"</span>; </span><br><span class="line">String str3 = str2 + <span class="string">"c"</span>;</span><br><span class="line">System.out.println(str1 == str3);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面是为什么返回<code>false</code>的？<code>str3</code>是在运行时确定的，这里其实会创建两个对象，一个<code>StringBuilder</code>对象和一个<code>String</code>对象。<code>String str3 = str2 + &quot;c&quot;</code>会被优化成<code>new StringBuilder(str2).append(&quot;c&quot;).toString()</code>，通过<code>StringBuilder.toString()</code>的源码方法看到返回一个新的<code>String</code>对象，所以<code>false</code></p><p><strong>上面对字符串的拼接做了一个总结，<code>String</code>内部重写了<code>equals</code>方法，应使用<code>equals</code>进行比较</strong></p><h4 id="5-常见问题"><a href="#5-常见问题" class="headerlink" title="5. 常见问题"></a>5. 常见问题</h4><h5 id="的错误用法"><a href="#的错误用法" class="headerlink" title="+的错误用法"></a>+的错误用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    str = str + <span class="string">"b"</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>每一次循环都会产生一个<code>StringBuilder</code>对象和一个String对象，应避免这种写法，使用<code>StringBuilder</code>代替</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;String&lt;/code&gt;是大三刚学&lt;code&gt;Java&lt;/code&gt;的时候接触的，以前看&lt;code&gt;String&lt;/code&gt;的时候感觉很简单，感觉会用就行了，后来发现用的时候也会有很多问题，所以回来温习一下&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java基础" scheme="http://zzzzzzyn.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring循环依赖</title>
    <link href="http://zzzzzzyn.github.io/2020/05/17/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://zzzzzzyn.github.io/2020/05/17/Spring循环依赖/</id>
    <published>2020-05-17T03:37:22.000Z</published>
    <updated>2020-05-20T13:54:06.937Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h5><p>SpringBoot 2.1.4报错如下，看了一下是循环依赖的问题。即 A -&gt; B，B -&gt; A（ 我的代码里 A 服务内部注入了 B 服务，B 服务内部也注入了服务 A）</p><p><img src="https://img-blog.csdnimg.cn/20200514151609451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" alt></p><a id="more"></a><h5 id="2-错误代码"><a href="#2-错误代码" class="headerlink" title="2. 错误代码"></a>2. 错误代码</h5><p><img src="https://img-blog.csdnimg.cn/20200514151650595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" alt></p><h5 id="3-解决"><a href="#3-解决" class="headerlink" title="3. 解决"></a>3. 解决</h5><ol><li>使用  <code>@Lazy</code> 令两个服务中的其中一方懒加载</li></ol><p><img src="https://img-blog.csdnimg.cn/20200514151731366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" alt></p><ol start="2"><li>使用 <code>setter</code> 方式注入</li></ol><p><img src="https://img-blog.csdnimg.cn/20200514151749842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" alt></p><h5 id="4-原理"><a href="#4-原理" class="headerlink" title="4. 原理"></a>4. 原理</h5><p>只知道构造注入会造成循环依赖，有空回来填坑</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1. 问题&quot;&gt;&lt;/a&gt;1. 问题&lt;/h5&gt;&lt;p&gt;SpringBoot 2.1.4报错如下，看了一下是循环依赖的问题。即 A -&amp;gt; B，B -&amp;gt; A（ 我的代码里 A 服务内部注入了 B 服务，B 服务内部也注入了服务 A）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200514151609451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="日常踩坑" scheme="http://zzzzzzyn.github.io/tags/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM的高频知识点</title>
    <link href="http://zzzzzzyn.github.io/2020/04/23/JVM%E7%9A%84%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://zzzzzzyn.github.io/2020/04/23/JVM的高频知识点/</id>
    <published>2020-04-23T14:17:05.000Z</published>
    <updated>2020-04-23T14:22:21.225Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-JVM-年轻代到年老代晋升过程？"><a href="#1-JVM-年轻代到年老代晋升过程？" class="headerlink" title="1. JVM 年轻代到年老代晋升过程？"></a>1. JVM 年轻代到年老代晋升过程？</h5><ul><li>对象在Form和To之间来回复制，年龄达到15（默认值，可通过 MaxTenuringThreshold 修改），晋升老年代</li><li>分配对象超过eden内存的一半，直接进入老年代。小于eden一半但没有内存空间，进行minor GC，survivor也放不下，进入老年代</li><li>动态年龄判断，某个年龄对象超过survivor空间的一半，大于等于某个年龄的对象直接进入老年代</li></ul><a id="more"></a><h5 id="2-Minor-GC，Major-GC和Full-GC区别？"><a href="#2-Minor-GC，Major-GC和Full-GC区别？" class="headerlink" title="2. Minor GC，Major GC和Full GC区别？"></a>2. Minor GC，Major GC和Full GC区别？</h5><ul><li>Minor GC：年轻代GC</li><li>Major GC：年老代GC</li><li>Full GC：整个堆空间GC（年轻代和年老代）</li></ul><h5 id="3-发生-Full-GC-的几种情况？"><a href="#3-发生-Full-GC-的几种情况？" class="headerlink" title="3. 发生 Full GC 的几种情况？"></a>3. 发生 Full GC 的几种情况？</h5><ul><li>System.gc() 方法显示调用（只是建议进行GC）</li><li><strong>老年代空间不足</strong>：只有在<strong>新生代对象转入</strong>或<strong>大对象（数组等）</strong>分配时，老年代才会出现内存不足情况，若 Full GC后空间依旧不足，抛出<strong>内存溢出异常</strong></li><li>CMS GC时出现 <strong>promotion failed</strong> 和 <strong>concurrent mode failure</strong><ul><li>promotion failed：发生Minor GC时，survivor space放不下了，只能晋升老年代，老年代也放不下</li><li>concurrent mode failure：执行CMS GC的同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC）</li></ul></li><li>统计的到的Minor GC晋升老年代对象平均大小大于老年代剩余空间<ul><li>Hotspot为避免晋升失败，会统计之前每次Minor GC后晋升对象的平均大小是否可以被老年代容纳，不能的话会触发Full GC</li><li>例如第一次Minor GC后有6M晋升到老年代，那么下次Minor GC发生时就会检查老年代是否有6M大小的空间</li><li>新生代使用PS GC（并发GC收集器）时，PS GC只对当前负责，检查本次要晋升的对象大小能否被老年代容纳，不能的话出触发Full GC</li></ul></li><li>堆中分配很大的对象：特指需要大量连续空间的对象</li><li>调用了 jmap -histo:live [pid]：立即出发Full GC</li></ul><h5 id="4-如何拿到-JVM-的-dump-文件？"><a href="#4-如何拿到-JVM-的-dump-文件？" class="headerlink" title="4. 如何拿到 JVM 的 dump 文件？"></a>4. 如何拿到 JVM 的 dump 文件？</h5><ul><li>jstack [pid] &gt; xxx.txt：打印堆栈信息到文件</li><li>jstack -l [pid] &gt; xxx.txt：打印堆栈信息（包含锁）到文件</li><li>kill -3</li><li>添加 JVM 参数：-XX:+HEAPDUMPONOUTOFMEMORYERROR（在内存溢出是保存堆栈信息），一般配合 -XX:HeapDumpPath=PATH 使用（<strong>可用 jinfo 命令运行时修改</strong>）</li><li>jmap -dump:format=b,file=xxx.dump [pid]</li></ul><h5 id="5-JVM-出现-fullGC-很频繁，怎么去线上排查问题？"><a href="#5-JVM-出现-fullGC-很频繁，怎么去线上排查问题？" class="headerlink" title="5. JVM 出现 fullGC 很频繁，怎么去线上排查问题？"></a>5. JVM 出现 fullGC 很频繁，怎么去线上排查问题？</h5><ul><li>jstat 查看GC信息观察GC后的堆空间大小并判断是否空间不足导致<ul><li>空间不足导致：拿到 dump 文件，放入 JVisualVM 观察原因</li><li>空间充足：观察程序中有没显示调用 System.gc() 方法</li></ul></li></ul><h5 id="6-对象如何进行访问定位？"><a href="#6-对象如何进行访问定位？" class="headerlink" title="6. 对象如何进行访问定位？"></a>6. 对象如何进行访问定位？</h5><ul><li><p>句柄：在堆空间中开辟一块空间用来存放句柄池，句柄池存放对象的类型指针和对象的实例指针，reference指针指向句柄</p><ul><li><p>好处：reference指向稳定的句柄，当堆空间进行gc时，对象的移动只会改变句柄中的对象实例指针，对reference没有影响</p><img src="https://img-blog.csdnimg.cn/20200422222425338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" style="zoom:67%;"></li></ul></li><li><p>直接指针：堆中实例对象存放实例类型，reference指针直接指向实例对象</p><ul><li><p>好处：速度更快，节省一次指针定位的开销</p><img src="https://img-blog.csdnimg.cn/2020042222245792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" style="zoom:67%;"></li></ul></li></ul><h5 id="7-对象创建过程？"><a href="#7-对象创建过程？" class="headerlink" title="7. 对象创建过程？"></a>7. 对象创建过程？</h5><ol><li>类加载检查：虚拟机遇到一条new指令，首先检查指令的参数能否在常量池（元空间）中定位到这个类的符号引用，并检查这个类是否被加载、解析和初始化过，如果没有则执行类加载过程</li><li><strong>分配内存</strong>：对象所需内存大小在类加载完成后便可确定，为对象在堆中划出一块<ul><li><strong>分配内存的两种方式</strong>：<ul><li><strong>指针碰撞</strong>：堆空间使用时是规整的，只需要把分界点的指针移动对象大小位置即可</li><li><strong>空闲列表</strong>：堆空间使用时不是规整的，空闲区域维护在一个列表中，分配时先查询列表，分配完之后更新列表</li><li><strong>堆空间分配是否规整由所采用的的垃圾收集器的算法决定</strong></li></ul></li><li>并发情况下内存空间的安全分配的两种方式（跟锁的安全策略其实差不多，原理上相同）<ul><li><strong>CAS失败重试</strong>，直至成功</li><li><strong>TLAB</strong>，预先为每个线程在eden区分配空间，JVM在线程中分配内存时首先在TLAB分配，TLAB剩余空间不足或用尽时，采用CAS失败重试继续进行内存分配</li></ul></li></ul></li><li>初始化零值：虚拟机需要将内存空间都初始化为零值，保证对象实例字段在java中不经赋初始值就可被调用</li><li>设置对象头：设置类的元数据信息、对象的哈希码、GC分代年龄。根据虚拟机当前运行状态的不同，决定是否使用偏向锁</li><li>执行init方法：一般来说，执行<code>new</code>指令之后会执行<code>init</code>方法，把对象按照我们的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</li></ol><h5 id="8-GC对象的判定方法？"><a href="#8-GC对象的判定方法？" class="headerlink" title="8. GC对象的判定方法？"></a>8. GC对象的判定方法？</h5><ul><li>引用计数法：为对象添加计数器，有引用该对象的地方时，计数器+1<ul><li>优点：效率高，简单</li><li>缺点：存在循环引用问题</li></ul></li><li>可达性分析算法：通过一系列GcRoots的对象为起点向下搜索，走过的路径为引用链，没在引用链上为废弃对象 <ul><li><strong>可做为GCRoot的对象</strong>（jdk1.7）：<ul><li>虚拟机栈引用的对象</li><li>方法区中类静态属性引用的变量（static对象）</li><li>方法区中常量引用的对象（final对象）</li><li>本地方法栈中Native方法引用的变量</li></ul></li></ul></li></ul><h5 id="9-四种引用？"><a href="#9-四种引用？" class="headerlink" title="9. 四种引用？"></a>9. 四种引用？</h5><ul><li>强引用：new对象就是强引用，JVM抛出OOM也不会清除</li><li>软引用：JVM内存不足时会回收软引用对象</li><li>弱引用：JVM只要进行GC就会回收弱引用对象</li><li>虚引用：幽灵引用，虚引用不会对对象生命周期产生印象，也无法通过虚引用获取对象</li></ul><h5 id="10-垃圾回收算法？"><a href="#10-垃圾回收算法？" class="headerlink" title="10. 垃圾回收算法？"></a>10. 垃圾回收算法？</h5><ul><li>标记清除：先标记再清除，有效率问题且会产生大量不连续的内存碎片</li><li>标记整理：先标记，将标记数据移到内存一端，清除其余部分，有效率问题但不会产生内存碎片</li><li>复制算法：将内存一份为二，使用一半内存，当垃圾回收时将存活对象放入另一半，然后清理自己的内存。好处是效率高且没有内存碎片，但会牺牲一半内存。在jvm中年轻代使用复制算法，但年轻代对象都是朝生夕死，所以内存分配时eden占用80%，而survivor占用%20来使用</li><li>分代算法：新生代复制算法，老年代标记整理或标记清除</li></ul><h5 id="11-垃圾收集器？"><a href="#11-垃圾收集器？" class="headerlink" title="11. 垃圾收集器？"></a>11. 垃圾收集器？</h5><ul><li>Serial收集器：年轻代串行收集器，当GC收集时，工作线程必须暂停(<strong>stop the world</strong>)直至收集结束，使用<strong>复制</strong>算法</li><li>Serial Old收集器：年老代串行收集器，特性和Serial一样，使用<strong>标记整理</strong>算法</li><li>Parallel Scavenge收集器：年轻代并行收集器，吞吐量优先收集器，使用<strong>复制</strong>算法</li><li>Parallel Old收集器：年老代并行收集器，使用<strong>标记整理</strong>算法</li><li>ParNew收集器：年轻代并行收集器，Serial收集器的多线程版本，为了配合CMS而生，<strong>复制</strong>算法</li><li>CMS收集器：年老代并发收集器，目标是最短停顿回收时间，注重用户体验，<strong>标记清除</strong>算法</li><li>运行过程：<ul><li>初始标记（Stop-The-World）：仅标记GCRoot能关联到的对象<ul><li>并发标记：标记GCRoot关联的所有不相关对象（从<strong>并发</strong>就可以看出，他是和用户线程一起工作的）</li><li>重新标记（Stop-The-World）：对并发标记期间因用户操作而导致标记变动的对象进行重新标记</li><li>并发清除：进行清除</li></ul></li><li><strong>优点：最短停顿回收时间，注重用户体验</strong></li><li><strong>缺点：</strong><ul><li><strong>CPU资源敏感</strong></li><li><strong>无法处理浮动垃圾</strong>，浮动垃圾过多时会启用Serial Old收集器</li><li><strong>大量内存碎片</strong>，再次分配大对象分配不下时，会引发一次FullGC，通过-XX：+UseCMSCompactAtFullCollection，在要进行FullGC时，进行内存整理（无法并发，慢）</li></ul></li></ul></li><li><strong>G1收集器：</strong><img src="https://img-blog.csdnimg.cn/20200422222524587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" style="zoom:67%;"></li></ul><h5 id="12-理解GC日志？"><a href="#12-理解GC日志？" class="headerlink" title="12. 理解GC日志？"></a>12. 理解GC日志？</h5><h5 id="13-JVM常用参数？"><a href="#13-JVM常用参数？" class="headerlink" title="13. JVM常用参数？"></a>13. JVM常用参数？</h5><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC" target="_blank" rel="noopener">Oracle的官方文档</a></p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/最重要的JVM参数指南" target="_blank" rel="noopener">JVM常用参数指南</a></p><h5 id="14-分配担保机制？"><a href="#14-分配担保机制？" class="headerlink" title="14. 分配担保机制？"></a>14. 分配担保机制？</h5><p>在发生Minor GC前，JVM检查新生代总大小是否可被老年代最大连续空间容纳，可容纳时进行Minor GC，否则检查是否允许分配担保失败，如果允许，判断老年代最大连续空间是否大于以往晋升对象的平均大小，若大于，进行Minor GC（有风险，可能这次超出平均大小，老年代接不住）。若小于或不允许分配担保失败，则转为执行Full GC</p><h5 id="15-类加载机制？"><a href="#15-类加载机制？" class="headerlink" title="15. 类加载机制？"></a>15. 类加载机制？</h5><ul><li><p><strong>加载</strong>：</p><ol><li><p>通过全类名获取类的二进制字节流</p></li><li><p>将字节流所代表的的静态存储结构转换为方法区（元空间）的运行时数据结构</p></li><li><p>在内存中生成代表该类的Class文件，作为方法区（元空间）这些数据的访问入口</p></li></ol></li><li><p><strong>验证</strong>：</p><ol><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol></li><li><p><strong>准备</strong>：正式为类变量分配内存并设置类变量初始值（就是默认值），例如<code>public static int val = 111;</code>，这里分配的是初值0；</p></li><li><p><strong>解析</strong>：<strong>将虚拟机常量池内的符号引用替换为直接引用的过程</strong>，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7种符号引用进行</p></li><li><p><strong>初始化</strong>：执行类构造器<code>&lt;client&gt;()</code>方法过程，比如上面的静态变量<code>val</code>会被赋值为111</p><img src="https://img-blog.csdnimg.cn/20200423112106659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" style="zoom:67%;"></li></ul><h5 id="16-类卸载条件？"><a href="#16-类卸载条件？" class="headerlink" title="16. 类卸载条件？"></a>16. 类卸载条件？</h5><p>类卸载即该类的class对象被GC</p><ol><li>该类的所有的实例对象都被GC，即堆中不存在该类的实例对象</li><li>该类没有在其他地方被引用</li><li>该类的类加载器的实例已被GC</li></ol><h5 id="17-类加载器？"><a href="#17-类加载器？" class="headerlink" title="17. 类加载器？"></a>17. 类加载器？</h5><p>对任意一个类，都需要加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器都有一个独立的类名称空间</p><p>JVM内置三个重要的类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：使用C++语言实现，是虚拟机自身的一部分</li><li>扩展类加载器（Extension CLassLoader）：加载<code>&lt;JAVA_HOME&gt;\lib&#39;ext</code>目录中的，或被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库</li><li>应用程序类加载器（Application ClassLoader）：这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader()</code>方法的返回值，<strong>负责加载用户类路径（ClassPath）上的指定类库，我们写的类文件被这个类所加载</strong></li></ul><h5 id="18-什么是双亲委派模型，为什么使用？"><a href="#18-什么是双亲委派模型，为什么使用？" class="headerlink" title="18. 什么是双亲委派模型，为什么使用？"></a>18. 什么是双亲委派模型，为什么使用？</h5><p>类加载器之间的层次关系称为双亲委派模型，双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都要有自己的父类加载器</p><p>双亲委派模型工作过程：如果一个类加载器收到类加载请求，它首先不会自己去加载这个类，而是委托给父类加载器加载，因此所有加载请求都会传送到最顶层启动类加载器中，父类加载器不能加载时会反馈自己无法完成加载请求，子类加载器才会尝试加载。大致就是（<strong>有事往上报，上头处理不了，会扔回来让你自己处理</strong>）</p><p>为什么使用：上面说过一个类的唯一性由加载它的类加载器和类本身一同决定。举个栗子：假如没有使用双亲委派模型，你自己写了一个java.lang.Object类，你自己加载，我使用的时候怎么知道到底用哪个Object。所以使用双亲委派模型是为了<strong>保证程序的稳定运行</strong></p><img src="https://img-blog.csdnimg.cn/20200423120155116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" style="zoom:67%;"><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><a href="https://www.jianshu.com/p/e749782fff2b" target="_blank" rel="noopener">JVM 出现 fullGC 很频繁，怎么去线上排查问题</a></p><p><a href="https://blog.csdn.net/jack85986370/article/details/79892951" target="_blank" rel="noopener">堆内存占用很小 但是 JVM 频繁full gc 问题排查</a></p><p><a href="https://blog.csdn.net/Soinice/article/details/98068404" target="_blank" rel="noopener">JVM面试题整理</a></p><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">深入理解Java虚拟机(第2版)</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-JVM-年轻代到年老代晋升过程？&quot;&gt;&lt;a href=&quot;#1-JVM-年轻代到年老代晋升过程？&quot; class=&quot;headerlink&quot; title=&quot;1. JVM 年轻代到年老代晋升过程？&quot;&gt;&lt;/a&gt;1. JVM 年轻代到年老代晋升过程？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;对象在Form和To之间来回复制，年龄达到15（默认值，可通过 MaxTenuringThreshold 修改），晋升老年代&lt;/li&gt;
&lt;li&gt;分配对象超过eden内存的一半，直接进入老年代。小于eden一半但没有内存空间，进行minor GC，survivor也放不下，进入老年代&lt;/li&gt;
&lt;li&gt;动态年龄判断，某个年龄对象超过survivor空间的一半，大于等于某个年龄的对象直接进入老年代&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JVM" scheme="http://zzzzzzyn.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap源码(JDK1.8)</title>
    <link href="http://zzzzzzyn.github.io/2020/04/19/LinkedHashMap%E6%BA%90%E7%A0%81(JDK8)/"/>
    <id>http://zzzzzzyn.github.io/2020/04/19/LinkedHashMap源码(JDK8)/</id>
    <published>2020-04-19T03:37:22.000Z</published>
    <updated>2020-04-23T13:48:26.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><code>LinkedHashMap</code>继承了<code>HashMap</code>，并在其基础上维护了一条双向链表，用来保证顺序访问。</p><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h3><h4 id="2-1-内部类和属性"><a href="#2-1-内部类和属性" class="headerlink" title="2.1 内部类和属性"></a>2.1 内部类和属性</h4><p><code>LinkedHashMap</code>的内部类继承了<code>Node</code>，并根据需要增加了before，after属性。这两个属性你肯定似曾相识，在<code>LinkedList</code>中使用过。其实他们的功能其实是一样的，定位前一个或后一个<code>entry</code>。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">// 排序方式，true：访问顺序排序(LRU) false：插入顺序排序</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它的属性都在hashmap中，这里就不一一列出了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap的内容存储类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 前后指针</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h4><p>通过下面的代码可以看出，<code>LinkedHashMap</code>的构造方法基本是调用父类构造来完成的，自己只是完成<code>accessOrder</code>属性操作（也就是排序方式，默认false）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显式指定是否启用有序访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-插入方法和钩子方法"><a href="#2-3-插入方法和钩子方法" class="headerlink" title="2.3 插入方法和钩子方法"></a>2.3 插入方法和钩子方法</h4><p><code>LinkedHashMap</code>的元素获取是调用<code>HashMap</code>的<code>put</code>方法，不过<code>LinkedHashMap</code>通过重写<code>HashMap</code>的钩子方法来实现一些自己的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">   …… 省略无关代码</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);<span class="comment">// 钩子方法</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 钩子方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钩子方法的定义(在HashMap中为空实现，留给子类重写逻辑)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap</span></span><br><span class="line"><span class="comment">// 节点访问后，移动元素e到链尾，频繁访问的元素就会落在尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// accessOrder为null且tail节点不是e，才会进入方法</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, </span><br><span class="line">        <span class="comment">// b为e的前驱节点，a为p的后继节点</span></span><br><span class="line">        b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;<span class="comment">// b=null说明e为头结点，则将后继a设为头节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;<span class="comment">// b!=null，将b的后继设置为a</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;<span class="comment">// a!=null，将a的前驱设置为b</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;<span class="comment">// a=null则将last设置为b</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;<span class="comment">// p为头结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;<span class="comment">// 设置p和last的链接关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;<span class="comment">// 设置p为尾节点</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在put方法调用到这里evict为true</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        <span class="comment">// 作用显而易见，移除首节点</span></span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);<span class="comment">// 在HashMap中，这里不再解释</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法总是返回false，你可能会疑惑这个鬼东西是否有问题。</span></span><br><span class="line"><span class="comment">// 其实这个方法是一个钩子方法，留给你自己来实现决定是否删除first(LRU算法实现)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点删除后断开链接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-获取方法"><a href="#2-4-获取方法" class="headerlink" title="2.4 获取方法"></a>2.4 获取方法</h4><p>了解了<code>hashmap</code>的<code>getNode</code>方法和上边的钩子方法，那么这里看起来就比较无脑了，没啥逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 调用hashmap的getNode获取entry</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 决定是否更新e到链尾</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-移除方法"><a href="#2-5-移除方法" class="headerlink" title="2.5 移除方法"></a>2.5 移除方法</h4><p>移除方法更没营养，调用<code>HashMap</code>的<code>remove</code>方法时调用了一下<code>afterNodeRemoval</code>方法。</p><h4 id="2-6-LRU缓存实现"><a href="#2-6-LRU缓存实现" class="headerlink" title="2.6 LRU缓存实现"></a>2.6 LRU缓存实现</h4><p>主要内容其实就是重写<code>LinkedHashMap</code>的<code>removeEldestEntry</code>方法，<code>Mybatis</code>也用<code>LinkedHashMap</code>实现LRU算法，也是这个套路，懂就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘抄自石杉的LRU实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传递进来最多能缓存多少数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheSize 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span></span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钩子方法，通过put新增键值对的时候，若该方法返回true</span></span><br><span class="line"><span class="comment">     * 便移除该map中最老的键和值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>总结好难，不总结了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;继承了&lt;code&gt;HashMap&lt;/code&gt;，并在其基础上维护了一条双向链表，用来保证顺序访问。&lt;/p&gt;
&lt;h3 id=&quot;2-源码分析&quot;&gt;&lt;a href=&quot;#2-源码分析&quot; class=&quot;headerlink&quot; title=&quot;2. 源码分析&quot;&gt;&lt;/a&gt;2. 源码分析&lt;/h3&gt;&lt;h4 id=&quot;2-1-内部类和属性&quot;&gt;&lt;a href=&quot;#2-1-内部类和属性&quot; class=&quot;headerlink&quot; title=&quot;2.1 内部类和属性&quot;&gt;&lt;/a&gt;2.1 内部类和属性&lt;/h4&gt;&lt;p&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;的内部类继承了&lt;code&gt;Node&lt;/code&gt;，并根据需要增加了before，after属性。这两个属性你肯定似曾相识，在&lt;code&gt;LinkedList&lt;/code&gt;中使用过。其实他们的功能其实是一样的，定位前一个或后一个&lt;code&gt;entry&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="集合框架" scheme="http://zzzzzzyn.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码</title>
    <link href="http://zzzzzzyn.github.io/2020/04/11/ThreadLocal%E6%BA%90%E7%A0%81/"/>
    <id>http://zzzzzzyn.github.io/2020/04/11/ThreadLocal源码/</id>
    <published>2020-04-11T03:37:22.000Z</published>
    <updated>2020-04-23T13:45:36.641Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h4><p><code>ThreadLocal</code>有三个属性<code>threadLocalHashCode</code>、<code>nextHashCode</code>、<code>HASH_INCREMENT</code></p><ul><li><code>threadLocalHashCode</code>属于对象的，每个<code>ThreadLocal</code>对象<code>hashcode</code>在初始化时确定且不可变</li><li><code>nextHashCode</code>属性是静态的随着<code>ThreadLocal</code>类的加载而加载，分配一个<code>AtomicInteger</code>对象，用来以原子的方式获取最新的<code>hashcode</code></li><li><code>HASH_INCREMENT</code>是下一个<code>hashcode</code>增长数，是一个静态常量</li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 每个ThreadLocal实例的hashcode(在对象被创建时赋值)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="comment">// 下一个要给出的hashcode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">// hash增长数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回下一个hash码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原子的方法更新值(调用unsafe操作)</span></span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h4><h5 id="2-1-get"><a href="#2-1-get" class="headerlink" title="2.1 get()"></a>2.1 get()</h5><p>用来获取线程的私有变量，操作步骤如下：</p><ol><li>获取当前线程的<code>threadLocalMap</code>属性，若初始化完成则进入步骤2，否则进行初始化</li><li>通过<code>threadLocal</code>去<code>threadLocalMap</code>获取对应entry，若无<code>entiry</code>则进行初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程中threadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 判断threadLocalMap有没有被初始化</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取entity</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// entity为null(可能发生内存泄漏，所以设置初始值)</span></span><br><span class="line">        <span class="comment">// 此时的引用链为Thread-&gt;ThreadLocalMap-&gt;Entry(null)-&gt;value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程t的threadLocalMap</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置初始值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始值(null)</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 放入map</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="comment">// 创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化value</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-set"><a href="#2-2-set" class="headerlink" title="2.2 set()"></a>2.2 set()</h5><p>set方法用来设置value到线程的<code>threadLocalMap</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-remove"><a href="#2-3-remove" class="headerlink" title="2.3 remove()"></a>2.3 remove()</h5><p>移除<code>ThreadLocalmap</code>中的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-内部类ThreadLocalMap"><a href="#3-内部类ThreadLocalMap" class="headerlink" title="3. 内部类ThreadLocalMap"></a>3. 内部类ThreadLocalMap</h4><p><code>ThreadLocalMap</code>的结构如下图</p><p><img src="https://img-blog.csdnimg.cn/20200410165604808.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" alt></p><h5 id="3-1-为什么Entry要继承弱引用？"><a href="#3-1-为什么Entry要继承弱引用？" class="headerlink" title="3.1 为什么Entry要继承弱引用？"></a>3.1 为什么Entry要继承弱引用？</h5><p><code>Entry</code>实现了对Key(也就是<code>ThreadLocal</code>)的弱引用。如果使用强引用，只要线程没有被销毁，<code>ThreadLocal</code>就一直是引用可达状态，永远无法被回收，程序不可知<code>ThreadLocal</code>是否可被清理。如果使用弱引用，当没有强引用链可达时，则活不过下一个GC，<code>ThreadLocal</code>会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部类Entry，实现了弱引用Key</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态常量：Table默认初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// Entry数组</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">// 初始大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实际上Entry[]数组以一个环的形式存在</span></span><br><span class="line">    <span class="comment">// 获取下一个下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取上一个下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造方法(懒加载，至少放入一个KV)</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];<span class="comment">// 16</span></span><br><span class="line">        <span class="comment">// 做与运算确定下标，和HashMap确定下标方式一样</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 构建entry放入table[i]</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        <span class="comment">// 设置ThreadLocalMap大小</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-getEntity-方法"><a href="#3-2-getEntity-方法" class="headerlink" title="3.2 getEntity()方法"></a>3.2 getEntity()方法</h5><p>获取<code>ThreadLocalMap</code>中的value，步骤如下：</p><ol><li>若<code>ThreadLocalMap</code>对应下标处的<code>entry</code>存在且<code>entry</code>的key就是传入key，返回value，否则进入2</li><li>至此说明<strong>hash冲突</strong>或<code>entry</code>不存在，如果<code>entry</code>不存在，则返回null，否则进入3</li><li>从e开始线性探测向后查找不为null的<code>entry</code>，若命中则返回value，若发现失效<code>entry</code>则进行连续段清理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取entry，被ThreadLocal的get方法调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 与运算获取到key对应下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 下标处entry存在 且 Entry的弱引用key没有失效</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在getEntry()中未命中，使用本方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 基于线性探测法不断向后探测直至遇到空的Entry</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 命中</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 弱引用key失效被回收，清理下标i无效的Entry</span></span><br><span class="line">            expungeStaleEntry(i); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 线性探测下一个位置</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 清除staleSlot开始的陈旧条目(连续段的清理)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下标staleSlot的value引用断开，原entry的ThreadLocal已被回收，此时原value对象可被回收</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 下标staleSlot出entry引用断开</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);(e = tab[i]) != <span class="keyword">null</span>;i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 对已回收的Entry进行清理操作</span></span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// rehash重新确定位置</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 重新取模后的h位置与原位置i不相等，</span></span><br><span class="line"><span class="comment">             * 则从h向后线性探测找到第一个空的位置，将tab[i]放入</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回staleSlot之后第一个空索引</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-set-方法"><a href="#3-3-set-方法" class="headerlink" title="3.3 set()方法"></a>3.3 set()方法</h5><p>设置<code>ThreadLocalMap</code>中的kv，步骤如下：</p><ol><li>通过hash拿到下标，下标处为null，直接插入，否则进入2</li><li>下标处开始向后遍历，此时可能遇到三种情况：<ul><li>key值相等，直接替换value</li><li>key失效，插入到此位置</li></ul></li><li>是否需要rehash</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 获取key的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash冲突，下标i位置存在Entry</span></span><br><span class="line"><span class="comment">     * 这时的Entry有两种状态：</span></span><br><span class="line"><span class="comment">     * Entry的ThreadLocal未被回收，若ThreadLocal为k直接放入value</span></span><br><span class="line"><span class="comment">     * Entry的ThreadLocal被回收，替换无效slot</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];e != <span class="keyword">null</span>;e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到对应的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Entry的ThreadLocal被回收，直接替换</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i下标处放入Entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 替换陈旧条目</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前遍历，找到第一个entry存在但key无效的slot</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向后遍历tab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到对应key，与无效slot交换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定清理点</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 做一次连续段清理，再做一次启发式清理</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前slot无效且向前扫描没有无效条目，更新slotToExpunge为当前位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若key在tab中不存在，直接插入</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过slotToExpunge判断是否存在无效条目，若存在，清除</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启发式清理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 永远为一个有效条目，从下一个索引开始判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 扫描log2(n)个单元，除非找到无效slot</span></span><br><span class="line"><span class="comment"> *插入方法调用时，此参数是元素数量</span></span><br><span class="line"><span class="comment"> * replaceStaleEntry方法调用时，此参数是table长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 清理过任何无效slot，则返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="comment">// e为无效slot</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清理连续段</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 删除过任何无效slot，返回true</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做全量清理</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用较低阈值判断是否需要扩容，上面做了清理，size可能会减小</span></span><br><span class="line"><span class="comment">     * 这里用threshold的3/4来判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除表中所有过时条目</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// entry为无效slot</span></span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将table的容量加倍,对遍历过程中的无效entry直接断开value</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历确定位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="comment">// 判断entry存在</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">// 判断key是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 冲突处理</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-4-remove-方法"><a href="#3-4-remove-方法" class="headerlink" title="3.4 remove()方法"></a>3.4 remove()方法</h5><p>通过key移除entry</p><ol><li>通过hash找到下标开始位置</li><li>向后遍历直至遇到null为止，判断key是否为传入的key，若是清理<code>entry</code>并调用连续段清理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 找到i开始向后查找，找到对应的entry，清理</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];e != <span class="keyword">null</span>;e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 清理</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-ThreadLocal的常见问题？"><a href="#4-ThreadLocal的常见问题？" class="headerlink" title="4. ThreadLocal的常见问题？"></a>4. ThreadLocal的常见问题？</h4><h5 id="4-1-ThreadLocal为什么发生内存泄露？"><a href="#4-1-ThreadLocal为什么发生内存泄露？" class="headerlink" title="4.1 ThreadLocal为什么发生内存泄露？"></a>4.1 ThreadLocal为什么发生内存泄露？</h5><p>因为<code>ThreadLocal</code>被<code>ThreadLocalMap</code>的Entry以弱引用的方式做key，当发生GC时，<code>ThreadLocal</code>就会被回收，此时引用链为<strong>Thread-&gt;ThreadLocalMap-&gt;Entry(null)-&gt;Value</strong>，当线程无法结束(<strong>线程池场景，使用完后归还线程池</strong>)时，Value将不会被清理，发生内存泄露</p><p>解决：使用<code>static</code>修饰<code>ThreadLocal</code>变量，<code>set()</code>，<code>get()</code>使用完成之后<strong>手动调用<code>remove()</code>方法清除<code>ThreadLocal</code></strong></p><blockquote><p>参考：<a href="https://www.cnblogs.com/micrari/" target="_blank" rel="noopener">ThreadLocal源码解读</a>，<a href="https://www.cnblogs.com/ricklz/p/9006424.html" target="_blank" rel="noopener">散列表–线性探测法</a>，<a href="https://www.cnblogs.com/1693977889zz/p/11111568.html" target="_blank" rel="noopener">ThreadLocal问题</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-属性&quot;&gt;&lt;a href=&quot;#1-属性&quot; class=&quot;headerlink&quot; title=&quot;1. 属性&quot;&gt;&lt;/a&gt;1. 属性&lt;/h4&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;有三个属性&lt;code&gt;threadLocalHashCode&lt;/code&gt;、&lt;code&gt;nextHashCode&lt;/code&gt;、&lt;code&gt;HASH_INCREMENT&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;threadLocalHashCode&lt;/code&gt;属于对象的，每个&lt;code&gt;ThreadLocal&lt;/code&gt;对象&lt;code&gt;hashcode&lt;/code&gt;在初始化时确定且不可变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextHashCode&lt;/code&gt;属性是静态的随着&lt;code&gt;ThreadLocal&lt;/code&gt;类的加载而加载，分配一个&lt;code&gt;AtomicInteger&lt;/code&gt;对象，用来以原子的方式获取最新的&lt;code&gt;hashcode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HASH_INCREMENT&lt;/code&gt;是下一个&lt;code&gt;hashcode&lt;/code&gt;增长数，是一个静态常量&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://zzzzzzyn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发框架" scheme="http://zzzzzzyn.github.io/tags/%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis的缓存</title>
    <link href="http://zzzzzzyn.github.io/2020/04/05/Mybatis%E7%9A%84%E7%BC%93%E5%AD%98/"/>
    <id>http://zzzzzzyn.github.io/2020/04/05/Mybatis的缓存/</id>
    <published>2020-04-05T05:53:22.000Z</published>
    <updated>2020-04-23T14:11:27.197Z</updated>
    
    <content type="html"><![CDATA[<h4 id="缓存实现类"><a href="#缓存实现类" class="headerlink" title="缓存实现类"></a>缓存实现类</h4><p>Mybatis的缓存实现应用了装饰器模式，基础缓存为<code>PerpetualCache</code>，其余的缓存类都在装饰<code>PerpetualCache</code>来实现不同的功能，下面图是部分实现</p><p><img src="https://img-blog.csdnimg.cn/20200406181005954.png" alt></p><a id="more"></a><h5 id="1-PerpetualCache"><a href="#1-PerpetualCache" class="headerlink" title="1. PerpetualCache"></a>1. PerpetualCache</h5><p>这个缓存比较简单，使用Map来达到缓存的目的。下边是他的源码，比较简单，只贴出了部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="comment">// 存储缓存内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-装饰器"><a href="#2-装饰器" class="headerlink" title="2. 装饰器"></a>2. 装饰器</h5><h6 id="2-1-FifoCache"><a href="#2-1-FifoCache" class="headerlink" title="2.1 FifoCache"></a>2.1 FifoCache</h6><p>先进先出式缓存，在<code>PerpetualCache</code>的基础上添加了一个队列集合来实现</p><p>插入缓存时：</p><ul><li>将缓存的key放入到keyList中，检查keyList的长度是否越界(越界移除掉队列头元素，并移除delegate中的kv)</li><li>将kv插入到delegate中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FifoCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// PerpetualCache</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">  <span class="comment">// 存放delegate中的key集合实现先进先出</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Object&gt; keyList;</span><br><span class="line">    <span class="comment">// keyList的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FifoCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="comment">// 用LinkedList做队列使用</span></span><br><span class="line">   <span class="keyword">this</span>.keyList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置keyList的最大值为1024</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">   cycleKeyList(key);</span><br><span class="line">delegate.putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对key的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加到队列尾</span></span><br><span class="line">    keyList.addLast(key);</span><br><span class="line">    <span class="keyword">if</span> (keyList.size() &gt; size) &#123;</span><br><span class="line">    <span class="comment">// 若keyList的size超过最大容量时，移除队列头元素</span></span><br><span class="line">    Object oldestKey = keyList.removeFirst();</span><br><span class="line">    <span class="comment">// 移除delegate中的key</span></span><br><span class="line">    delegate.removeObject(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-2-LruCache"><a href="#2-2-LruCache" class="headerlink" title="2.2 LruCache"></a>2.2 LruCache</h6><p>最近最少使用缓存，通过重写<code>LinkedHashMap</code>的<code>removeEldestEntry()</code>来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// PerpetualCache</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">    <span class="comment">// 用于维护最近最少使用key</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; keyMap;</span><br><span class="line">    <span class="comment">// 需要移除的key(也就是最近最少使用的key)</span></span><br><span class="line">  <span class="keyword">private</span> Object eldestKey;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">setSize(<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 维护LinkedHashMap的访问顺序，这里弄懂需要跟一下LinkedListMap的put源码</span></span><br><span class="line">keyMap = <span class="keyword">new</span> LinkedHashMap&lt;Object, Object&gt;(size, .<span class="number">75F</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4267176411845948333L</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Object, Object&gt; eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">boolean</span> tooBig = size() &gt; size;</span><br><span class="line">        <span class="keyword">if</span> (tooBig) &#123;</span><br><span class="line">                    <span class="comment">// 当长度越界后，返回LinkedList的头结点的key</span></span><br><span class="line">          eldestKey = eldest.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tooBig;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    delegate.putObject(key, value);</span><br><span class="line">    cycleKeyList(key);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将key存入keyMap</span></span><br><span class="line">    keyMap.put(key, key);</span><br><span class="line">    <span class="keyword">if</span> (eldestKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// delegate中移除eldestKey并将eldestKey置null</span></span><br><span class="line">      delegate.removeObject(eldestKey);</span><br><span class="line">      eldestKey = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-3-BlockingCache"><a href="#2-3-BlockingCache" class="headerlink" title="2.3 BlockingCache"></a>2.3 BlockingCache</h6><p>阻塞式缓存，使用<code>ReentrantLock</code>来实现的，同一时刻只有一个线程可以key的缓存</p><p>线程A访问缓存时，</p><ul><li>通过<strong>getObject()</strong>方法加锁，当缓存命中，返回值不为null(释放锁)</li><li>当缓存未命中，返回null(不释放锁)，mybatis查询数据库，将结果放入缓存(putObject()方法)，此时释放锁</li></ul><p>线程A操作缓存时，线程B进入获取和A相同的key时，只能等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"><span class="comment">// 超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">  <span class="comment">// PerpetualCache</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">  <span class="comment">// 存储锁</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, ReentrantLock&gt; locks;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BlockingCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    <span class="keyword">this</span>.locks = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getId();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询缓存</span></span><br><span class="line">            delegate.putObject(key, value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 释放锁</span></span><br><span class="line">      releaseLock(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试加锁</span></span><br><span class="line">        acquireLock(key);</span><br><span class="line">        Object value = delegate.getObject(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// value不为null时才会释放锁</span></span><br><span class="line">          releaseLock(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// despite of its name, this method is called only to release locks</span></span><br><span class="line">    releaseLock(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    delegate.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ReentrantLock <span class="title">getLockForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁对象</span></span><br><span class="line">    <span class="keyword">return</span> locks.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Lock lock = getLockForKey(key);</span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在timeout时间内尝试加锁</span></span><br><span class="line">            <span class="keyword">boolean</span> acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (!acquired) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Couldn't get a lock in "</span> + timeout + <span class="string">" for the key "</span> + key + <span class="string">" at the cache "</span> + delegate.getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Got interrupted while trying to acquire lock for key "</span> + key, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = locks.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">        <span class="comment">// 当锁被当前线程持有才会释放</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> timeout;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;<span class="keyword">this</span>.timeout = timeout;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CacheKey"><a href="#CacheKey" class="headerlink" title="CacheKey"></a>CacheKey</h4><p>CacheKey主要用来充当Mybatis一二级缓存(<code>PerpetualCache</code>存储)的key，value肯定为数据库的返回结果，这点毋容置疑。那么key的选择会麻烦一些，需要考虑到方法id、参数列表、是否分页、执行的SQL等因素。所以有了CacheKey</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1146682552656046210L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheKey NULL_CACHE_KEY = <span class="keyword">new</span> CacheKey() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Not allowed to update a null cache key instance."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAll</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Not allowed to update a null cache key instance."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 默认乘子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLIER = <span class="number">37</span>;</span><br><span class="line">    <span class="comment">// 默认hash</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line">    <span class="comment">// 实际乘子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> multiplier;</span><br><span class="line">    <span class="comment">// 实际hash</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line">    <span class="comment">// 校验和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">    <span class="comment">// 影响因子个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 影响因子(像方法id，参数列表这些都是影响因子)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hashcode = <span class="number">17</span>;</span><br><span class="line">        <span class="keyword">this</span>.multiplier = <span class="number">37</span>;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.updateAll(objects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取影响因子个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUpdateCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.updateList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新操作(目的是为了hashcode更随机，因为这是需要作为map的key的)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取基础hashcode</span></span><br><span class="line">        <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line">        <span class="comment">// count自增1</span></span><br><span class="line">        ++<span class="keyword">this</span>.count;</span><br><span class="line">        <span class="comment">// 校验和更新</span></span><br><span class="line">        <span class="keyword">this</span>.checksum += (<span class="keyword">long</span>)baseHashCode;</span><br><span class="line">        <span class="comment">// 基础hash更新</span></span><br><span class="line">        baseHashCode *= <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="comment">// 实际hash更新</span></span><br><span class="line">        <span class="keyword">this</span>.hashcode = <span class="keyword">this</span>.multiplier * <span class="keyword">this</span>.hashcode + baseHashCode;</span><br><span class="line">        <span class="comment">// 添加影响因子到列表</span></span><br><span class="line">        <span class="keyword">this</span>.updateList.add(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将objects逐一放入到udateList中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAll</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">        Object[] var2 = objects;</span><br><span class="line">        <span class="keyword">int</span> var3 = objects.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            Object o = var2[var4];</span><br><span class="line">            <span class="keyword">this</span>.update(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为要作为缓存的key，所以重写了hash和equals</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">            <span class="comment">// 比较内存地址</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 比较类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CacheKey cacheKey = (CacheKey)object;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">                <span class="comment">// 比较hash</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.checksum != cacheKey.checksum) &#123;</span><br><span class="line">                <span class="comment">// 比较校验和</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.count != cacheKey.count) &#123;</span><br><span class="line">                <span class="comment">// 比较影响因子个数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 比较每个影响因子</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.updateList.size(); ++i) &#123;</span><br><span class="line">                    Object thisObject = <span class="keyword">this</span>.updateList.get(i);</span><br><span class="line">                    Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hashcode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>Mybatis的一级缓存是使用<code>PerpetualCache</code>来做的，key为CacheKey，value为数据库返回的结果集。会在INSERT|UPDATE|DELETE、事务提交、回滚时清空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"><span class="comment">// 一级缓存</span></span><br><span class="line">    <span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取绑定SQL</span></span><br><span class="line">        BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">        <span class="comment">// 获取cacheKey</span></span><br><span class="line">        CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">        <span class="comment">// 调用重载，真正逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回cacheKey对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">            <span class="comment">// 传入ms的id：com.xyn.mapper.Rolemapper.getRole</span></span><br><span class="line">            cacheKey.update(ms.getId());</span><br><span class="line">            <span class="comment">// 分页参数</span></span><br><span class="line">            cacheKey.update(rowBounds.getOffset());</span><br><span class="line">            cacheKey.update(rowBounds.getLimit());</span><br><span class="line">            <span class="comment">// sql</span></span><br><span class="line">            cacheKey.update(boundSql.getSql());</span><br><span class="line">            <span class="comment">// 参数列表</span></span><br><span class="line">            List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">            TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">            Iterator var8 = parameterMappings.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                ParameterMapping parameterMapping = (ParameterMapping)var8.next();</span><br><span class="line">                <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">                    String propertyName = parameterMapping.getProperty();</span><br><span class="line">                    Object value;</span><br><span class="line">                    <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        value = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                        value = parameterObject;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        MetaObject metaObject = <span class="keyword">this</span>.configuration.newMetaObject(parameterObject);</span><br><span class="line">                        value = metaObject.getValue(propertyName);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// 传入运行时参数：#&#123;xx&#125;</span></span><br><span class="line">                    cacheKey.update(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 存在环境变量时传入环境变量</span></span><br><span class="line">                cacheKey.update(<span class="keyword">this</span>.configuration.getEnvironment().getId());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cacheKey;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正的查询业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若查询栈深度为1 且 ms是否清空缓存(根据ms类型决定,select类型为false,其余为true)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">                <span class="comment">// 清空一级缓存</span></span><br><span class="line">                <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List list;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 栈深度自增</span></span><br><span class="line">                ++<span class="keyword">this</span>.queryStack;</span><br><span class="line">                <span class="comment">// 从一级缓存中取，若为null，则去数据库查询</span></span><br><span class="line">                list = resultHandler == <span class="keyword">null</span> ? (List)<span class="keyword">this</span>.localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 存储过程逻辑</span></span><br><span class="line">                    <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 从数据库中取</span></span><br><span class="line">                    list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 栈深度自减</span></span><br><span class="line">                --<span class="keyword">this</span>.queryStack;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">                <span class="comment">// 检查本地缓存使用范围，若为(STATEMENT)则清空localCache</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从数据库查询</span></span><br><span class="line">    <span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 插入占位符 没搞太懂这个操作</span></span><br><span class="line">        <span class="keyword">this</span>.localCache.putObject(key, ExecutionPlaceholder.EXECUTION_PLACEHOLDER);</span><br><span class="line"></span><br><span class="line">        List list;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list = <span class="keyword">this</span>.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 移除占位符</span></span><br><span class="line">            <span class="keyword">this</span>.localCache.removeObject(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询结果放入到localCache中</span></span><br><span class="line">        <span class="keyword">this</span>.localCache.putObject(key, list);</span><br><span class="line">        <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">            <span class="comment">// 若为存储过程，放入到localOutputParameterCache中</span></span><br><span class="line">            <span class="keyword">this</span>.localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p><strong>TODO</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;缓存实现类&quot;&gt;&lt;a href=&quot;#缓存实现类&quot; class=&quot;headerlink&quot; title=&quot;缓存实现类&quot;&gt;&lt;/a&gt;缓存实现类&lt;/h4&gt;&lt;p&gt;Mybatis的缓存实现应用了装饰器模式，基础缓存为&lt;code&gt;PerpetualCache&lt;/code&gt;，其余的缓存类都在装饰&lt;code&gt;PerpetualCache&lt;/code&gt;来实现不同的功能，下面图是部分实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200406181005954.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mybatis" scheme="http://zzzzzzyn.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="http://zzzzzzyn.github.io/2020/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <id>http://zzzzzzyn.github.io/2020/03/24/计算机网络笔记/</id>
    <published>2020-03-24T03:37:22.000Z</published>
    <updated>2020-04-23T14:09:50.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-3-因特网的组成"><a href="#1-3-因特网的组成" class="headerlink" title="1.3 因特网的组成"></a>1.3 因特网的组成</h3><h4 id="两种通信方式"><a href="#两种通信方式" class="headerlink" title="两种通信方式"></a>两种通信方式</h4><ol><li><p>客户端服务器方式(C/S方式)，Client/Server方式</p><p>就像我们Java开发的系统，部署一个网站，那个网站所在主机就是服务器。用户通过浏览器访问网站，浏览器就是客户端</p></li><li><p>对等方式(P2P方式)，Peer-toPeer方式</p></li></ol><a id="more"></a><h4 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h4><ol><li><p>电路交换：基本可以做到实时通信</p><ul><li>电路交换的过程：建立连接–&gt;通信–&gt;关闭连接</li><li>适用场景：使用数据量很大的实时性传输</li><li>像我们打电话，就是电路交换。拨号等待就是建立连接的过程，对话就是通信，挂断就是关闭连接</li></ul></li><li><p>分组交换：将数据分组传输</p><ul><li><p>优点：高效，灵活，迅速，可靠</p></li><li><p>缺点：时延，开销</p></li><li><p>计算机就采用分组传输，不需要建立路径，只需要给分段数据加上目标头部即可</p></li></ul></li><li><p>报文交换：不分组，直接加个目标首部传输，时延长，开销大</p></li></ol><h3 id="1-6-计算机性能"><a href="#1-6-计算机性能" class="headerlink" title="1.6 计算机性能"></a>1.6 计算机性能</h3><ul><li>速率：连接在计算机网络上的<strong>主机</strong>在数字信道上传送<strong>数据位数</strong>的速率，也称比特率<ul><li>单位：b/s，kb/s，Mb/s，Gb/s</li><li>我们手机下载软件看到的速度，就是在下载信道上的速率，xxkb/s，xMb/s这种，</li></ul></li><li>带宽：数据通信领域，数字信道所传送的最高数据率(他和速率打配合，多条信道，最高带宽)<ul><li>单位：b/s，kb/s，Mb/s，Gb/s</li></ul></li><li><strong>吞吐量</strong>：单位时间内通过某个网络的数据量<ul><li>单位：b/s，Mb/s等</li></ul></li><li>时延：</li><li>时延带宽积：传播时延*带宽</li><li><strong>往返时间</strong>：从发送发发送数据开始，到发送方收到接收方确认</li><li>利用率：信道利用率和网络利用率组成<ul><li>信道利用率：有数据通过时间/(有+无)数据通过时间</li><li>网络利用率：网络空闲时的时延/(1-信道利用率)</li></ul></li></ul><h3 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h3><h4 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h4><p>应用层–&gt;表示层–&gt;会话层–&gt;传输层–&gt;网络层–&gt;数据链路层–&gt;物理层</p><h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h4><p>应用层–&gt;传输层–&gt;网络层–&gt;数据链路层</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-3-传输层协议"><a href="#5-3-传输层协议" class="headerlink" title="5.3 传输层协议"></a>5.3 传输层协议</h3><h4 id="5-3-1-TCP协议概述"><a href="#5-3-1-TCP协议概述" class="headerlink" title="5.3.1 TCP协议概述"></a>5.3.1 TCP协议概述</h4><ul><li>TCP是<strong>面向连接</strong>的传输层协议</li><li>每一天TCP协议连接只能有两个端点，每一条TCP连接只能是<strong>点对点</strong>的(一对一)</li><li>TCP提供<strong>可靠交付</strong>的服务</li><li>TCP提供<strong>全双工</strong>通信</li><li><strong>面向字节流</strong></li></ul><h4 id="5-3-2-TCP连接"><a href="#5-3-2-TCP连接" class="headerlink" title="5.3.2 TCP连接"></a>5.3.2 TCP连接</h4><ul><li>TCP把连接作为最基本的抽象</li><li>每一条TCP连接有两个端点</li><li>TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字(socket)</strong>或插口(是不是联想到了Java的Socket连接)</li><li><strong>端口号拼接到IP地址即构成了套接字</strong> </li><li>套接字<ul><li>套接字socket=(IP地址: 端口号)</li><li>TCP连接= {socket1, socket2}={(IP1: port1), (IP2: port2)}</li></ul></li></ul><h4 id="5-3-3-TCP协议实现可靠传输"><a href="#5-3-3-TCP协议实现可靠传输" class="headerlink" title="5.3.3 TCP协议实现可靠传输"></a>5.3.3 TCP协议实现可靠传输</h4><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><img src="https://img-blog.csdnimg.cn/20200323121149776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><ul><li>情况(a)无差错情况，A发送M1，B收到并确认M1，A收到M1的确认并发送M2，直至完成</li><li>情况(b)超时重传，A发送M1，在M1到达B时数据包丢了，那么B肯定不会给A发送M1的确认。此时的A在一直等待M1的确认，在等待数据往返时间更多一点时间后，判定M1发送失败，重新发送M1，重复情况(a)</li></ul><img src="https://img-blog.csdnimg.cn/20200323122027992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><ul><li>情况(a)确认丢失，A发送M1，在M1正确到达B，B发送M1的确认，但M1的确认丢失了，此时A在一直等待M1的确认，在等待数据往返时间更多一点时间后，判定M1发送失败，重新发送M1，这时B会收到重复的M1，丢弃重复的M1并给A发送M1的确认</li><li>情况(b)确认迟到，A发送M1，在M1正确到达B，B发送M1的确认，M1的确认由于某些原因迟到了。A在等待M1的确认，超过一定时间重新发送给M1，B收到重复的M1，丢弃重复的M1并发送M1的确认，开始AB正常的收发。但一段时间后A收到了迟到的M1的确认，但A什么也不做</li></ul><h5 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h5><p>上面的停止等待协议会造成信道利用率低的问题，所以有了流水线传输</p><ul><li>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认</li><li>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率</li></ul><img src="https://img-blog.csdnimg.cn/20200323123159494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><h5 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h5><p>ARQ：自动重传请求</p><p>用一个滑动窗口来发送请求，假设这个窗口可以存放5个数据，A一次发送5个，B收到1位置的数据，发送窗口滑动，而B如果全部收到的话，只需要发送5，就表示1-5的数据包全部收到了，此时会滑动5个位置</p><img src="https://img-blog.csdnimg.cn/20200323123601687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><h4 id="5-3-4-三次握手"><a href="#5-3-4-三次握手" class="headerlink" title="5.3.4 三次握手"></a>5.3.4 三次握手</h4><p>为什么是三次握手？</p><ol><li>第一次client告诉server，我要连接你，server被动打开了</li><li>第二次server回复client，哥准备好了，你来吧</li><li>第三次client，好嘞，我知道你好了</li></ol><p>这里有个必问的问题，明明两次就可以建立连接，为什么还要第三次？</p><h4 id="5-3-5-四次挥手"><a href="#5-3-5-四次挥手" class="headerlink" title="5.3.5 四次挥手"></a>5.3.5 四次挥手</h4><p>为什么是四次挥手？</p><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="7-1-对称加密"><a href="#7-1-对称加密" class="headerlink" title="7.1 对称加密"></a>7.1 对称加密</h3><h3 id="7-2-非对称加密和数字签名"><a href="#7-2-非对称加密和数字签名" class="headerlink" title="7.2 非对称加密和数字签名"></a>7.2 非对称加密和数字签名</h3><h3 id="7-3-证书颁发机构CA"><a href="#7-3-证书颁发机构CA" class="headerlink" title="7.3 证书颁发机构CA"></a>7.3 证书颁发机构CA</h3><h3 id="7-4-安全套接字SSL"><a href="#7-4-安全套接字SSL" class="headerlink" title="7.4 安全套接字SSL"></a>7.4 安全套接字SSL</h3><p>第七章就是讲的是https的原理</p><ol><li>client请求server，server（server像CA机构获取公钥私钥）传输公钥给client，client通过SSL验证公钥合法性</li><li>client发送用公钥加密过的对称秘钥给server，server使用私钥解析获得对称秘钥，至此SSL功能完成</li><li>client和server开始使用对称秘钥进行通信</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;h3 id=&quot;1-3-因特网的组成&quot;&gt;&lt;a href=&quot;#1-3-因特网的组成&quot; class=&quot;headerlink&quot; title=&quot;1.3 因特网的组成&quot;&gt;&lt;/a&gt;1.3 因特网的组成&lt;/h3&gt;&lt;h4 id=&quot;两种通信方式&quot;&gt;&lt;a href=&quot;#两种通信方式&quot; class=&quot;headerlink&quot; title=&quot;两种通信方式&quot;&gt;&lt;/a&gt;两种通信方式&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;客户端服务器方式(C/S方式)，Client/Server方式&lt;/p&gt;
&lt;p&gt;就像我们Java开发的系统，部署一个网站，那个网站所在主机就是服务器。用户通过浏览器访问网站，浏览器就是客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对等方式(P2P方式)，Peer-toPeer方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://zzzzzzyn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis粗讲</title>
    <link href="http://zzzzzzyn.github.io/2020/03/06/Redis%E7%B2%97%E8%AE%B2/"/>
    <id>http://zzzzzzyn.github.io/2020/03/06/Redis粗讲/</id>
    <published>2020-03-06T05:53:22.000Z</published>
    <updated>2020-06-06T01:29:27.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Redis是什么？"><a href="#1-Redis是什么？" class="headerlink" title="1. Redis是什么？"></a>1. Redis是什么？</h3><p>C语言开发的高性能键值对的<strong>内存数据库</strong>，可以用来做缓存、消息中间件、数据库(noSql)。</p><a id="more"></a><h3 id="2-Redis都有哪些基本数据类型？"><a href="#2-Redis都有哪些基本数据类型？" class="headerlink" title="2. Redis都有哪些基本数据类型？"></a>2. Redis都有哪些基本数据类型？</h3><table><thead><tr><th>类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td>string(字符串)</td><td>二进制存储</td><td>可以包含任何数据，图片或序列化对象</td><td>验证码、cookie、session存储</td></tr><tr><td>hash(字典)</td><td>相当于java中的map</td><td>适合存储对象，每次修改一个属性</td><td>修改对象的信息</td></tr><tr><td>list(列表)</td><td>双向链表</td><td>增删快</td><td>排行榜，消息队列(阻塞添加获取功能)</td></tr><tr><td>set(集合)</td><td>元素不重复</td><td>增加、删除、查询时间复杂度为O(1)，做交集补集差集</td><td>共同好友</td></tr><tr><td>sorted set(有序集合)</td><td>为set中元素增加一个权重，元素按权重有序排列</td><td>数据插入集合时就根据权重进行了排序</td><td>排行榜、带权重的消息队列</td></tr><tr><td>bit(位图)</td><td>相当于一个数组</td><td></td><td>做用户签到，登录统计</td></tr><tr><td>hyperLogLog</td><td></td><td>数据统计不太准确</td><td>做网站的UV，PV</td></tr><tr><td>geo(地理位置)</td><td></td><td></td><td>附近的人功能</td></tr></tbody></table><h3 id="3-在项目里是如何使用Redis的？"><a href="#3-在项目里是如何使用Redis的？" class="headerlink" title="3. 在项目里是如何使用Redis的？"></a>3. 在项目里是如何使用Redis的？</h3><p>emmm，一般集成在<code>springboot</code>中使用，使用<code>springboot</code>的<code>RedisTemplate</code>或者<code>StringRedisTemplate</code>。</p><h3 id="4-使用缓存遇到的问题？"><a href="#4-使用缓存遇到的问题？" class="headerlink" title="4. 使用缓存遇到的问题？"></a>4. 使用缓存遇到的问题？</h3><ul><li>缓存雪崩：同一时间大量key失效导致直接访问数据库。<ul><li>解决：①固定失效时间+随机失效时间。②主备两个redis，备库的key过期时间较长</li></ul></li><li>缓存穿透：一直访问数据库中不存在的key为缓存穿透。<ul><li>解决：①接口层参数校验，用户鉴权等。②直接把key和value为null放入缓存，设置短一点的有效期。③布隆过滤器(分布式：redis布隆过滤器插件，单机：guava)</li></ul></li><li>缓存击穿：热点key的过期为击穿。解决：设置热点key永不过期或互斥锁解决。</li></ul><h3 id="5-过期策略"><a href="#5-过期策略" class="headerlink" title="5. 过期策略"></a>5. 过期策略</h3><p>定期删除+惰性删除</p><ul><li>定期删除：每隔一段时间随机抽取设置过期时间的key，检测是否过期，过期就删除。</li><li>惰性删除：当访问到过期key是，删除过期key，不返回</li></ul><h3 id="6-内存淘汰机制"><a href="#6-内存淘汰机制" class="headerlink" title="6. 内存淘汰机制"></a>6. 内存淘汰机制</h3><table><thead><tr><th>过期策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>设置过期时间键值对中，最近最少未使用</td></tr><tr><td>allkeys-lru</td><td>所有键值对，最近最少未使用</td></tr><tr><td>volatile-lfu</td><td>设置过期时间键值对中，访问频率最少的淘汰</td></tr><tr><td>allkeys-lfu</td><td>所有键值对中，访问频率最少的淘汰</td></tr><tr><td>volatile-random</td><td>设置过期时间键值对中，随机淘汰</td></tr><tr><td>allkeys-random</td><td>所有键值对中，随机淘汰</td></tr><tr><td>volatile-ttl</td><td>设置过期时间键值对中，剩余时间短的淘汰</td></tr><tr><td>noeviction</td><td>从不淘汰，内存不足时报错</td></tr></tbody></table><h3 id="7-持久化"><a href="#7-持久化" class="headerlink" title="7. 持久化"></a>7. 持久化</h3><p>redis提供两种持久化方案，RDB和AOF。</p><ul><li><p>RDB：在指定时间间隔对数据进行快照存储。</p><ul><li>优点：<ul><li>保存某个时间点的数据集，适合做数据备份。</li><li>保存RDB时，父进程fork一个子进程进行RDB的写入，父进程只需对数据进行关注，性能较高。</li><li>恢复大的数据集是，RDB相比AOF会更快一些。</li></ul></li><li>缺点：<ul><li>在redis宕机时，可能会丢失几分钟的数据。</li><li>大数据量情况下，对RDB备份会对性能有一些影响。</li></ul></li></ul></li><li><p>AOF：每次写入都会将命令追加进aof文件。</p><ul><li>优点：<ul><li>AOF相比RDB使redis更加耐久，默认策略每秒fsync，当redis宕机最多丢失1秒数据。</li><li>redis可以在aof文件体积过大时重写aof文件，只写入执行内存中数据最少命令。</li><li>AOF文件可以被非常简单可读，当不小心执行<code>flushall</code>(删库)命令时，只要AOF文件未被重写，那么找到AOF文件，删掉flushall命令，重启redis即可挽回。</li></ul></li><li>缺点：<ul><li>对相同数据集，AOF文件体积大于RDB文件。</li><li>不同fsync策略会影响AOF的速度，不过在响应方面会低于RDB。</li></ul></li></ul></li></ul><p>如何使用两种持久化方式？看数据丢失的承受性，可单用，可混合使用，一般情况混合使用。</p><h3 id="8-高可用"><a href="#8-高可用" class="headerlink" title="8. 高可用"></a>8. 高可用</h3><p>主从复制+哨兵</p><ul><li>哨兵(Sentinel)作用？<ul><li><strong>监控</strong>：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li><strong>提醒</strong>：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移</strong>：当一个主服务器不能正常工作时，Sentinel 会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li></ul></li></ul><p>redis cluster</p><blockquote><p>参考：<a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Redis是什么？&quot;&gt;&lt;a href=&quot;#1-Redis是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Redis是什么？&quot;&gt;&lt;/a&gt;1. Redis是什么？&lt;/h3&gt;&lt;p&gt;C语言开发的高性能键值对的&lt;strong&gt;内存数据库&lt;/strong&gt;，可以用来做缓存、消息中间件、数据库(noSql)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="http://zzzzzzyn.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码(JDK1.8)</title>
    <link href="http://zzzzzzyn.github.io/2020/03/02/HashMap%E6%BA%90%E7%A0%81(JDK8)/"/>
    <id>http://zzzzzzyn.github.io/2020/03/02/HashMap源码(JDK8)/</id>
    <published>2020-03-02T03:37:22.000Z</published>
    <updated>2020-06-16T07:16:59.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><code>HashMap</code>是我们常用的集合类，以K-V形式的键值对来存储数据，散列算法实现，不保证键值对的顺序存储。</p><a id="more"></a><h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h3><p><code>HashMap</code>底层使用数组+链表+红黑树来存储数据，根据Key的hashCode扰动处理后得到的hash，通过<code>(n - 1) &amp; hash</code>确定位置，然后插入到链表或红黑树中(搞不懂可以继续往下看，用到的时候再说)。</p><img src="https://img-blog.csdnimg.cn/20200302133201121.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><p><code>HashMap</code>使用内部类<code>Node</code>和<code>TreeNode</code>来存储数据，还有一些重要的属性，都在下面代码中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Node数组 */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/** K-V键值对数量 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">/** 下次扩容时的阈值 */</span></span><br><span class="line"><span class="keyword">int</span> threshold;    </span><br><span class="line"><span class="comment">/** 负载因子 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">/** 默认初始容量，必须为2的幂 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line"><span class="comment">/** 默认负载因子 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">/** 链表转化红黑树阈值 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/** 红黑树退化链表阈值 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 链表节点，实现Map.Entry */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 扰动后的hash</span></span><br><span class="line">    <span class="keyword">final</span> K key;<span class="comment">// key</span></span><br><span class="line">    V value;<span class="comment">// value</span></span><br><span class="line">    Node&lt;K,V&gt; next;<span class="comment">// nextNode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 红黑树节点 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;  </span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中比较重要的属性有两个：</p><ul><li><strong>loadFactor</strong>：负载因子，取值在0-1之间。<strong>越接近1存放的数据越多，数据分布越密集、越接近0存放数据越少，数据分布稀疏</strong>。官方默认0.75f，可在构造时指定。</li><li><strong>threshold</strong>：扩容阈值，<strong>容量*负载因子</strong>。</li></ul><h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h3><h4 id="3-1构造方法"><a href="#3-1构造方法" class="headerlink" title="3.1构造方法"></a>3.1构造方法</h4><p><code>HashMap</code>有四个构造方法，无参依旧是经典选择，当然知晓需存储元素数量的情况下，依旧推荐指定容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义负载因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 指定初始容量 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用重载的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 指定初始容量和负载因子 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 传入实现map的子类 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回大于cap的最合适的2^n */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<strong>tableSizeFor(int cap)</strong>这个算法非常的巧妙，它可以找到最合适的2^n返回。假设传入的cap为11，n=10</p><ul><li>n |= n &gt;&gt;&gt; 1，等价于n或n&gt;&gt;&gt;1(无符号右移一位)，1010 | 0101 = 1111 就为15</li><li>n |= n &gt;&gt;&gt; 2，同上操作</li></ul><p>最后会得出合适的2^n，也就是16。</p><h4 id="3-2插入"><a href="#3-2插入" class="headerlink" title="3.2插入"></a>3.2插入</h4><p>将指定键值对相关联插入Map，若存在则替换Value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合的添加，也就是数组的尾部插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 判断table是否需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 判断指定位置是否存在元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 创建新节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断是否需要替换Value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 属于红黑树节点，插入红黑树</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 属于链表节点，找出尾节点，插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">       <span class="comment">// 是否尾节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 插入原尾节点之后</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断链表长度是否达到转换红黑树阈值</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中是否有相同的Key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换键值对的Value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// LinkedHashMap覆盖方法</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 更新size并判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于元素的添加，有一下两种情况：</p><ul><li>元素不存在，判断插入红黑树还是插入链表</li><li>元素存在，判断为红黑树节点，还是链表节点，替换Value</li></ul><img src="https://img-blog.csdnimg.cn/20200302161649461.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><p>图有点问题，<strong>转换红黑树</strong>那里应该是 <strong>数组扩容或链表转化为红黑树</strong></p><h4 id="3-3获取"><a href="#3-3获取" class="headerlink" title="3.3获取"></a>3.3获取</h4><p>键值对Value的获取相对put简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定键值对的Value，若不存在返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断table为null或长度为0或hash对应下标处为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            <span class="comment">// 首节点为key，返回first</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 红黑树节点</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 链表节点</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4扩容"><a href="#3-4扩容" class="headerlink" title="3.4扩容"></a>3.4扩容</h4><p><code>HashMap</code>的扩容需要进行rehash和元素遍历，非常耗时，应尽量避免</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.第一个判断，设置容量和阈值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 旧容量&gt;=MAXIMUM_CAPACITY，扩容不做处理，去碰撞吧，管不了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 新容量=旧容量*2，新扩容阈值=旧扩容阈值*2</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 新容量=旧扩容阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 新容量=16</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 新扩容阈值=0.75f*16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.设置扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 扩容阈值=容量*负载因子</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新Node数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历并将旧数组元素拷贝到新数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// oldTab[j]元素不为null</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// oldTab[j]上只有一个Node</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// e是红黑树节点，转为红黑树处理</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * oldTab[j]元素是一个链表</span></span><br><span class="line"><span class="comment">                     * 链表可能会分裂为两个链表，lo存放第一个链表的首尾，hi存放第二个链表的首尾</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 判断rehash后应在第一个链表上还是第二个链表上</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表拆解完成，放入newTab对应位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 新链表位置为j+oldCap</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面红黑树的扩容我也没搞太懂……就不拿出来显了，链表的扩容可能有点难以理解，为什么会分裂成两个链表，这里画个图，所以原位置上的key可能会拷贝到oldCap+j位置上。</p><img src="https://img-blog.csdnimg.cn/20200302212521408.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><h3 id="4-面试"><a href="#4-面试" class="headerlink" title="4.  面试"></a>4.  面试</h3><p>介绍的时候主要介绍</p><ul><li>数据结构：数组+链表+红黑树</li><li>插入时的流程</li><li>扩容时的流程</li></ul><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p><code>Hashmap</code>可学习的点非常多，建议自己去jdk中找源码看一看。面试可以通过<code>HashMap</code>扩展到ConcurrentHashmap然后再扩展到juc的集合工具类，可讲的点非常多，非常考察个人能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;是我们常用的集合类，以K-V形式的键值对来存储数据，散列算法实现，不保证键值对的顺序存储。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="集合框架" scheme="http://zzzzzzyn.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList源码</title>
    <link href="http://zzzzzzyn.github.io/2020/02/29/LinkedList%E6%BA%90%E7%A0%81/"/>
    <id>http://zzzzzzyn.github.io/2020/02/29/LinkedList源码/</id>
    <published>2020-02-29T03:06:16.000Z</published>
    <updated>2020-04-23T13:36:54.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><code>LinkedList</code>是长度可变的集合，基于链表来实现，和<code>ArrayList</code>都具有存储重复元素和空值的特点。因为基于链表实现，所以并不像数组那样需要连续的内存空间来存储元素，且在首尾插入元素的效率较高，时间复杂度为O(1)，但因为结构的问题，导致查询较慢，时间复杂度为O(n)。</p><a id="more"></a><h3 id="2-继承关系"><a href="#2-继承关系" class="headerlink" title="2. 继承关系"></a>2. 继承关系</h3><p>下图是<code>LinkedList</code>的继承体系(阉割版)，实现了<code>Deque</code>、<code>List</code>接口，继承<code>AbstractSequentialList</code>，<code>Deque</code>其实是一个双向链表接口，而<code>AbstractSequentialList</code>则提供的顺序访问方法。可以得知<code>LinkedList</code>是一个可存重、顺序访问的双向链表。</p><img src="https://img-blog.csdnimg.cn/20200228220109373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><p><code>LinkedList</code>可以顺序访问其实是重写了<code>AbstractSequentialList</code>的<code>ListIterator</code>方法，本质上就是通过迭代器来拿到指定位置元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AbstractSequentialList.class</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">LinkedList.class</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * next指向取出node(index)</span></span><br><span class="line"><span class="comment">         * node遍历列表来取出指定索引出的Node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h3><h4 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h4><p><code>LinkedList</code>有两个构造方法，一个无参一个有参。常用的肯定是无参构造，有参构造很少使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;<span class="comment">// 首节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 无参构造 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 构建一个指定集合元素的列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// pred前驱节点，succ后继节点</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组a的元素转换为节点</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断前驱节点是否为null</span></span><br><span class="line"><span class="comment">         * null：这个是空列表，将first指向自己</span></span><br><span class="line"><span class="comment">         * 非null：这不是空列表，将pred的next节点指向自己</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        <span class="comment">// 将pred指向新节点</span></span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 判断succ是否为null</span></span><br><span class="line"><span class="comment">      * null：这个是空列表，将last指向pred，也就是a的最后一个元素转换成节点</span></span><br><span class="line"><span class="comment">      * 非null：这不是空列表，更新pred的后继和succ的前驱</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新size</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-插入"><a href="#3-2-插入" class="headerlink" title="3.2 插入"></a>3.2 插入</h4><p>元素的插入也是有两种方式，一种是从尾部插入，另一种是插入指定位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 集合的添加 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 插入到指定位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 插入到链尾 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 插入到指定位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 1.取出succ的前驱pred</span></span><br><span class="line"><span class="comment">      * 2.构建新节点newNode</span></span><br><span class="line"><span class="comment">      * 3.更新原来的前驱节点和后继节点与newNode的关系</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加到集合尾部，时间复杂度O(1)</p><img src="https://img-blog.csdnimg.cn/2020022910410690.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><p>添加到指定位置，时间复杂度为O(1)，不过遍历寻址的时间复杂度为O(n)</p><img src="https://img-blog.csdnimg.cn/20200229104123116.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><h4 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h4><p>对于元素的删除，和<code>ArrayList</code>相同，<code>LinkedList</code>提供了两种删除方式，指定位置元素的删除，元素的删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 删除index位置元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回指定索引出的节点 */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">// 通过index和size决定首节点或尾节点开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 取消链表节点的x */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立前驱节点与后继节点的关联，这里注意首尾节点问题    </span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除对象o</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表元素的删除比较简单，主要就是对删除元素相关联的前驱后继关系的操作，大致步骤如下</p><ul><li>更新前驱节点</li><li>更新后继节点</li><li>更新size</li></ul><h4 id="3-4-遍历"><a href="#3-4-遍历" class="headerlink" title="3.4 遍历"></a>3.4 遍历</h4><p>遍历方式和<code>ArrayList</code>一样，不过因为自身结构问题，遍历一直是<code>LinkedList</code>的性能短板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">for</span> (Integer val : list) &#123;</span><br><span class="line">        System.out.println(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-面试"><a href="#4-面试" class="headerlink" title="4.  面试"></a>4.  面试</h3><p>介绍时可以从以下几个方面讲解<code>LinkedList</code></p><ul><li>线程安全方面</li><li>底层数据结构</li><li>插入删除元素与位置的影响</li><li>内存空间占用</li><li>效率，使用场景</li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>没啥总结，链表的结构记住就行。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt;是长度可变的集合，基于链表来实现，和&lt;code&gt;ArrayList&lt;/code&gt;都具有存储重复元素和空值的特点。因为基于链表实现，所以并不像数组那样需要连续的内存空间来存储元素，且在首尾插入元素的效率较高，时间复杂度为O(1)，但因为结构的问题，导致查询较慢，时间复杂度为O(n)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="集合框架" scheme="http://zzzzzzyn.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码</title>
    <link href="http://zzzzzzyn.github.io/2020/02/25/ArrayList%E6%BA%90%E7%A0%81/"/>
    <id>http://zzzzzzyn.github.io/2020/02/25/ArrayList源码/</id>
    <published>2020-02-25T03:37:22.000Z</published>
    <updated>2020-04-23T13:37:08.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><code>ArrayList</code>是长度可变的集合，基于定长数组来实现的，且可以存储重复元素和空值。当插入元素个数大于数组长度时，就需要进行扩容(其实就是创建一个更长的新数组)。因为底层基于数组实现，所以随机查找的时间复杂度为O(1)。</p><a id="more"></a><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h3><h4 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h4><p><code>ArrayList</code>有三个构造方法，一个无参两个有参，其中常用的为无参构造，推荐在知晓存储元素数量的情况下，使用有参构造<code>ArrayList(int initialCapacity)</code>，好处是避免数组扩容带来的额外开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将elementData初始化为空数组</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据initialCapacity初始化elementData</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个构造方法其实都是对elementData进行<strong>初始化</strong>的操作，<code>ArrayList(Collection&lt;? extends E&gt; c)</code>的作用是把<code>Collection</code>类型的元素全部添加到<code>ArrayList</code>中，平常开发中不常用到。</p><h4 id="2-2-插入"><a href="#2-2-插入" class="headerlink" title="2.2 插入"></a>2.2 插入</h4><p>数组元素的插入有两种方式，一种是从尾部插入，另一种是从任意指定位置插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合的添加，也就是数组的尾部插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容量检查</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1. size元素赋值e，</span></span><br><span class="line"><span class="comment">  * 2. size++</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将element插入到index位置，指定位置插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 指定位置插入，需要将从索引index开始的元素都后移一位，如果数据量大的话会比较耗时</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 新元素插入index位置</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是元素的两种添加方式，对添加操作而言，基本只有三个过程：</p><ul><li>容量检查，判断是否需要扩容</li><li>元素插入</li><li>size++</li></ul><p>添加到集合尾部，时间复杂度O(1)</p><img src="https://img-blog.csdnimg.cn/20200225104806790.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><p>添加到指定位置，时间复杂度为O(n)</p><img src="https://img-blog.csdnimg.cn/20200225105557440.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70"><h4 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h4><p>对于元素的删除，<code>ArrayList</code>提供了两种删除方式，指定位置元素的删除，元素的删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除index位置元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取index位置元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素移动长度</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 数组尾元素置null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除对象o</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速删除，跳过边界检查，不返回删除元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合元素的删除比较简单，基本和添加操作大同小异，大致过程如下：</p><ul><li><p>取出index位置元素</p></li><li><p>index+1开始的元素，前移一位</p></li><li><p>size–</p></li></ul><h4 id="2-4-扩容机制"><a href="#2-4-扩容机制" class="headerlink" title="2.4 扩容机制"></a>2.4 扩容机制</h4><p>数组是定长的，如果数据元素一致增加的话，会面临容量问题需要进行扩容(其实就是换一个更大的数组)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minCapacity &gt; elementData.length则需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 将原数组的元素拷贝到新数组，时间复杂度O(n)</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为数组的扩容涉及到数组的拷贝，时间复杂度O(n)，所以知晓元素数量情况下应设置容量。</p><h4 id="2-5-遍历"><a href="#2-5-遍历" class="headerlink" title="2.5 遍历"></a>2.5 遍历</h4><p>下面是 ArrayList 的几种迭代方式，推荐第一种方式，因为<code>ArrayList</code>实现了<code>RandomAccess</code>(随机访问的标志接口)，又因为底层是数组存储，取值的时间复杂度为O(1)，其余都是转化为迭代器进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer val : list) &#123;</span><br><span class="line">        System.out.println(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-面试"><a href="#3-面试" class="headerlink" title="3.  面试"></a>3.  面试</h3><p>介绍时可以从以下几个方面讲解<code>ArrayList</code></p><ul><li>线程安全方面</li><li>底层数据结构</li><li>插入删除元素与位置的影响</li><li>内存空间占用</li><li>效率，使用场景</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p><strong>ArrayList</strong>比较简单，源码基本可以很轻松地看懂，建议去自己翻阅一遍。</p><blockquote><p><a href="[http://www.tianxiaobo.com/2018/01/28/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/](http://www.tianxiaobo.com/2018/01/28/ArrayList源码分析/)">田小波-ArrayList源码分析</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt;是长度可变的集合，基于定长数组来实现的，且可以存储重复元素和空值。当插入元素个数大于数组长度时，就需要进行扩容(其实就是创建一个更长的新数组)。因为底层基于数组实现，所以随机查找的时间复杂度为O(1)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="集合框架" scheme="http://zzzzzzyn.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>redis.conf参数</title>
    <link href="http://zzzzzzyn.github.io/2020/01/01/redis-conf%E5%8F%82%E6%95%B0/"/>
    <id>http://zzzzzzyn.github.io/2020/01/01/redis-conf参数/</id>
    <published>2020-01-01T05:15:26.000Z</published>
    <updated>2020-01-01T05:18:31.114Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">参数说明</span><br><span class="line">redis.conf 配置项说明如下：</span><br><span class="line">1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class="line">  daemonize no</span><br><span class="line">2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span><br><span class="line">  pidfile /var/run/redis.pid</span><br><span class="line">3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</span><br><span class="line">  port 6379</span><br><span class="line">4. 绑定的主机地址</span><br><span class="line">  bind 127.0.0.1</span><br><span class="line">5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class="line">  timeout 300</span><br><span class="line">6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class="line">  loglevel verbose</span><br><span class="line">7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class="line">  logfile stdout</span><br><span class="line">8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</span><br><span class="line">  databases 16</span><br><span class="line">9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line">  save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">  Redis默认配置文件中提供了三个条件：</span><br><span class="line">  save 900 1</span><br><span class="line">  save 300 10</span><br><span class="line">  save 60 10000</span><br><span class="line">  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class="line"> </span><br><span class="line">10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class="line">  rdbcompression yes</span><br><span class="line">11. 指定本地数据库文件名，默认值为dump.rdb</span><br><span class="line">  dbfilename dump.rdb</span><br><span class="line">12. 指定本地数据库存放目录</span><br><span class="line">  dir ./</span><br><span class="line">13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class="line">  slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">14. 当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class="line">  masterauth &lt;master-password&gt;</span><br><span class="line">15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class="line">  requirepass foobared</span><br><span class="line">16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class="line">  maxclients 128</span><br><span class="line">17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class="line">  maxmemory &lt;bytes&gt;</span><br><span class="line">18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class="line">  appendonly no</span><br><span class="line">19. 指定更新日志文件名，默认为appendonly.aof</span><br><span class="line">   appendfilename appendonly.aof</span><br><span class="line">20. 指定更新日志条件，共有3个可选值： </span><br><span class="line">  no：表示等操作系统进行数据缓存同步到磁盘（快） </span><br><span class="line">  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span><br><span class="line">  everysec：表示每秒同步一次（折衷，默认值）</span><br><span class="line">  appendfsync everysec</span><br><span class="line"> </span><br><span class="line">21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</span><br><span class="line">   vm-enabled no</span><br><span class="line">22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class="line">   vm-swap-file /tmp/redis.swap</span><br><span class="line">23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class="line">   vm-max-memory 0</span><br><span class="line">24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class="line">   vm-page-size 32</span><br><span class="line">25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class="line">   vm-pages 134217728</span><br><span class="line">26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span><br><span class="line">   vm-max-threads 4</span><br><span class="line">27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class="line">  glueoutputbuf yes</span><br><span class="line">28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class="line">  hash-max-zipmap-entries 64</span><br><span class="line">  hash-max-zipmap-value 512</span><br><span class="line">29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class="line">  activerehashing yes</span><br><span class="line">30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class="line">  include /path/to/local.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
      <category term="redis" scheme="http://zzzzzzyn.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>nginx的安装</title>
    <link href="http://zzzzzzyn.github.io/2019/11/29/nginx%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://zzzzzzyn.github.io/2019/11/29/nginx的安装/</id>
    <published>2019-11-29T14:11:50.000Z</published>
    <updated>2019-11-29T14:19:34.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx作用"><a href="#nginx作用" class="headerlink" title="nginx作用"></a>nginx作用</h2><ul><li>反向代理<ul><li>暴露代理服务器地址，请求分发，对外给调用者感觉是一个服务器，</li></ul></li><li>负载均衡<ul><li>根据服务器情况分发请求</li></ul></li><li>动静分离<ul><li>动态资源(servlet,jsp)和静态资源(html,css,img)分离</li></ul></li></ul><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>安装下列依赖</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><ol start="2"><li>解压nginx的tar包</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-<span class="number">1.8</span>.0.tar.gzcd nginx-<span class="number">1.8</span>.0</span><br></pre></td></tr></table></figure><ol start="3"><li>配置参数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/<span class="keyword">var</span>/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/<span class="keyword">var</span>/lock/nginx.lock \</span><br><span class="line">--error-log-path=/<span class="keyword">var</span>/log/nginx/error.log \</span><br><span class="line">--http-log-path=/<span class="keyword">var</span>/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/<span class="keyword">var</span>/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/<span class="keyword">var</span>/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/<span class="keyword">var</span>/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/<span class="keyword">var</span>/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/<span class="keyword">var</span>/temp/nginx/scgi</span><br></pre></td></tr></table></figure><ol start="4"><li>编译</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ol start="5"><li>进入/usr/local/nginx/sbin下启动</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./nginx(可能会出现: [emerg] mkdir() <span class="string">"/var/temp/nginx/client"</span> failed (<span class="number">2</span>: No such file or directory)，我是直接在/<span class="keyword">var</span>/temp/nginx/client手动创建出来解决的)</span><br><span class="line">ps -ef | <span class="function">grep <span class="title">nginx</span><span class="params">(查看进程是否启动)</span></span></span><br></pre></td></tr></table></figure><h3 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h3><ol><li>查看版本号</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -v</span><br></pre></td></tr></table></figure><ol start="2"><li>停止nginx</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure><ol start="3"><li>重启nginx</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nginx作用&quot;&gt;&lt;a href=&quot;#nginx作用&quot; class=&quot;headerlink&quot; title=&quot;nginx作用&quot;&gt;&lt;/a&gt;nginx作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;反向代理&lt;ul&gt;
&lt;li&gt;暴露代理服务器地址，请求分发，对外给调用者感觉是一个服务器，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;负载均衡&lt;ul&gt;
&lt;li&gt;根据服务器情况分发请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动静分离&lt;ul&gt;
&lt;li&gt;动态资源(servlet,jsp)和静态资源(html,css,img)分离&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="后台" scheme="http://zzzzzzyn.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="nginx" scheme="http://zzzzzzyn.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>linux防火墙常用操作</title>
    <link href="http://zzzzzzyn.github.io/2019/11/18/linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://zzzzzzyn.github.io/2019/11/18/linux防火墙常用命令/</id>
    <published>2019-11-18T14:25:01.000Z</published>
    <updated>2019-11-18T14:30:41.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux防火墙常用命令"><a href="#linux防火墙常用命令" class="headerlink" title="linux防火墙常用命令"></a>linux防火墙常用命令</h2><ol><li><p>查看firewall服务状态</p><p>systemctl status firewalld</p></li><li><p>查看firewall状态<br>firewall-cmd –state</p></li></ol><a id="more"></a><ol start="3"><li><p>开启关闭重启防火墙<br>3.1 开启防火墙<br>service firewalld start<br>3.2 重启防火墙<br>service firewalld restart<br>3.3 关闭防火墙<br>service firewalld stop</p></li><li><p>查看防火墙规则<br>firewall-cmd –list-all </p></li><li><p>查询开放关闭端口<br>5.1 查询端口(8080)是否开放<br>firewall-cmd –query-port=8080/tcp<br>5.2 开放端口(8080)<br>firewall-cmd –permanent –add-port=8080/tcp<br>5.3 关闭端口(8080)<br>firewall-cmd –permanent –remove-port=8080/tcp</p></li><li><p>重启防火墙(配置修改后使用)<br>firewall-cmd –reload</p><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4></li><li><p>firwall-cmd：是Linux提供的操作firewall的一个工具；</p></li><li><p>–permanent：表示设置为持久；</p></li><li><p>–add-port：标识添加的端口；</p></li></ol><blockquote><p>转载自：<a href="https://www.cnblogs.com/xxoome/p/7115614.html" target="_blank" rel="noopener">https://www.cnblogs.com/xxoome/p/7115614.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;linux防火墙常用命令&quot;&gt;&lt;a href=&quot;#linux防火墙常用命令&quot; class=&quot;headerlink&quot; title=&quot;linux防火墙常用命令&quot;&gt;&lt;/a&gt;linux防火墙常用命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看firewall服务状态&lt;/p&gt;
&lt;p&gt;systemctl status firewalld&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看firewall状态&lt;br&gt;firewall-cmd –state&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="后台" scheme="http://zzzzzzyn.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="笔记" scheme="http://zzzzzzyn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="http://zzzzzzyn.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Intellij idea在debug时修改类自动加载</title>
    <link href="http://zzzzzzyn.github.io/2019/11/05/Intellij%20idea%E5%9C%A8debug%E6%97%B6%E4%BF%AE%E6%94%B9%E7%B1%BB%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://zzzzzzyn.github.io/2019/11/05/Intellij idea在debug时修改类自动加载/</id>
    <published>2019-11-05T12:37:53.000Z</published>
    <updated>2019-11-06T12:28:32.690Z</updated>
    
    <content type="html"><![CDATA[<p>debug时需要修改代码，但修改完还需要重启感觉特别麻烦，就找到了以下这个方法，当代码修改后，idea会自动加载修改的类</p><a id="more"></a><ol><li><p>ctrl+alt+s打开设置框，勾选设置<br><img src="https://img-blog.csdnimg.cn/20191104202419902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" alt></p></li><li><p>ctrl+shift+a弹出的页面搜索registry，并勾选<br><img src="https://img-blog.csdnimg.cn/20191104202555878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" alt></p></li><li><p>打开项目设置</p><p><img src="https://img-blog.csdnimg.cn/2019110420275079.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" alt><br><img src="https://img-blog.csdnimg.cn/20191104202654755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70" alt></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;debug时需要修改代码，但修改完还需要重启感觉特别麻烦，就找到了以下这个方法，当代码修改后，idea会自动加载修改的类&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译工具" scheme="http://zzzzzzyn.github.io/categories/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Intellij idea" scheme="http://zzzzzzyn.github.io/tags/Intellij-idea/"/>
    
  </entry>
  
  <entry>
    <title>springboot2.2.0打war包运行报错</title>
    <link href="http://zzzzzzyn.github.io/2019/10/27/springboot2.2.0%E6%89%93war%E5%8C%85%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99/"/>
    <id>http://zzzzzzyn.github.io/2019/10/27/springboot2.2.0打war包运行报错/</id>
    <published>2019-10-27T09:42:43.000Z</published>
    <updated>2019-10-27T09:45:53.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="springboot2-2-0版本打war包放入tomcat后加载不到mapper的bean"><a href="#springboot2-2-0版本打war包放入tomcat后加载不到mapper的bean" class="headerlink" title="springboot2.2.0版本打war包放入tomcat后加载不到mapper的bean"></a>springboot2.2.0版本打war包放入tomcat后加载不到mapper的bean</h3><p>今天本来想试一试maven多版本打包，用的是springboot2.2.0，什么都配好了结果war包放入tomcat后老是运行不起来，加载不到mybatis的bean，折腾了一下午，<strong>原因是springboot2.2.0有问题</strong>，将springboot版本回退就好了</p><p>下面是tomcat的主要报错信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">E:\apache-tomcat-<span class="number">9.0</span>.27\webapps\boot.war] 时出错</span><br><span class="line">java.lang.IllegalStateException: Error starting child</span><br><span class="line">at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:<span class="number">720</span>)</span><br><span class="line">at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:<span class="number">690</span>)</span><br><span class="line">at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:<span class="number">705</span>)</span><br><span class="line">at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:<span class="number">978</span>)</span><br><span class="line">at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:<span class="number">1849</span>)</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:<span class="number">75</span>)</span><br><span class="line">at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="number">112</span>)</span><br><span class="line">at org.apache.catalina.startup.HostConfig.deployWARs(HostConfig.java:<span class="number">773</span>)</span><br><span class="line">at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:<span class="number">427</span>)</span><br><span class="line">at org.apache.catalina.startup.HostConfig.start(HostConfig.java:<span class="number">1576</span>)</span><br><span class="line">at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:<span class="number">309</span>)</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:<span class="number">123</span>)</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:<span class="number">423</span>)</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:<span class="number">366</span>)</span><br><span class="line">at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:<span class="number">936</span>)</span><br><span class="line">at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:<span class="number">841</span>)</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">183</span>)</span><br><span class="line">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:<span class="number">1384</span>)</span><br><span class="line">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:<span class="number">1374</span>)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:<span class="number">75</span>)</span><br><span class="line">at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="number">134</span>)</span><br><span class="line">at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:<span class="number">909</span>)</span><br><span class="line">at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:<span class="number">262</span>)</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">183</span>)</span><br><span class="line">at org.apache.catalina.core.StandardService.startInternal(StandardService.java:<span class="number">421</span>)</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">183</span>)</span><br><span class="line">at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:<span class="number">930</span>)</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">183</span>)</span><br><span class="line">at org.apache.catalina.startup.Catalina.start(Catalina.java:<span class="number">633</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:<span class="number">344</span>)</span><br><span class="line">at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:<span class="number">475</span>)</span><br><span class="line">Caused by: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/boot]]</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.handleSubClassException(LifecycleBase.java:<span class="number">440</span>)</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">198</span>)</span><br><span class="line">at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:<span class="number">717</span>)</span><br><span class="line">... <span class="number">37</span> more</span><br><span class="line">Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'userController'</span>: Unsatisfied dependency expressed through field <span class="string">'userService'</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'userServiceImpl'</span>: Unsatisfied dependency expressed through field <span class="string">'userMapper'</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'userMapper'</span> defined in file [E:\apache-tomcat-<span class="number">9.0</span>.27\webapps\boot\WEB-INF\classes\com\boot\mapper\UserMapper.class]: Unsatisfied dependency expressed through bean property <span class="string">'sqlSessionFactory'</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration'</span>: Unsatisfied dependency expressed through constructor parameter <span class="number">0</span>; nested exception is org.springframework.boot.context.properties.ConfigurationPropertiesBindException: Error creating bean with name <span class="string">'mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties'</span>: Could not bind properties to <span class="string">'MybatisProperties'</span> : prefix=mybatis, ignoreInvalidFields=<span class="keyword">false</span>, ignoreUnknownFields=<span class="keyword">true</span>; nested exception is org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under <span class="string">'mybatis.configuration.mapped-statements[0].parameter-map.parameter-mappings[0]'</span> to org.apache.ibatis.mapping.ParameterMapping</span><br></pre></td></tr></table></figure><h3 id="pom文件设置多版本依赖"><a href="#pom文件设置多版本依赖" class="headerlink" title="pom文件设置多版本依赖"></a>pom文件设置多版本依赖</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;!--开发环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">    &lt;!--默认启动此配置--&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;spring.profiles.active&gt;dev&lt;/spring.profiles.active&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--测试环境--&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;test&lt;/id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;spring.profiles.active&gt;test&lt;/spring.profiles.active&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">        &lt;!--线上--&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;prod&lt;/id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;spring.profiles.active&gt;prod&lt;/spring.profiles.active&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class="line">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- 打包跳过test --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;skip&gt;true&lt;/skip&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">        &lt;!-- 修改war包名称 --&gt;</span><br><span class="line">        &lt;finalName&gt;boot&lt;/finalName&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure><p>application.yml</p><p>存放了一些通用配置，如mybatis的全局config和mapper位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: <span class="meta">@spring</span>.profiles.active@</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">9527</span></span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /boot</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  config-location: classpath:mybatis-config.xml</span><br><span class="line">  mapper-locations: classpath:mapper<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure><p>application-dev.yml</p><p>这是开发环境的yml配置，应该还有一份test和prod的yml，大致相同就不列出了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//127.0.0.1:3306/luntan</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;springboot2-2-0版本打war包放入tomcat后加载不到mapper的bean&quot;&gt;&lt;a href=&quot;#springboot2-2-0版本打war包放入tomcat后加载不到mapper的bean&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="后台" scheme="http://zzzzzzyn.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="那些年踩过的坑= =" scheme="http://zzzzzzyn.github.io/tags/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
      <category term="spring" scheme="http://zzzzzzyn.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>linux权限命令乞丐版</title>
    <link href="http://zzzzzzyn.github.io/2019/10/21/linux%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4%E4%B9%9E%E4%B8%90%E7%89%88/"/>
    <id>http://zzzzzzyn.github.io/2019/10/21/linux权限命令乞丐版/</id>
    <published>2019-10-21T13:49:43.000Z</published>
    <updated>2019-10-21T14:25:48.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="文件目录基本操作"><a href="#文件目录基本操作" class="headerlink" title="文件目录基本操作"></a>文件目录基本操作</h3><h4 id="文件-目录所有者"><a href="#文件-目录所有者" class="headerlink" title="文件/目录所有者"></a>文件/目录所有者</h4><p>默认文件的创建者是文件所有者</p><h5 id="查看文件的所有者"><a href="#查看文件的所有者" class="headerlink" title="查看文件的所有者"></a>查看文件的所有者</h5><p>ls -ahl：查看文件所有者</p><p>下图所示：红线是文件所有者，蓝线是文件所有组</p><p><img src="https://img-blog.csdnimg.cn/20191021214545157.png" alt></p><a id="more"></a><h5 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h5><p><strong>chown 用户名  文件名：改变文件所有者</strong></p><p>chown  tom   a.tar.gz：将a.tar.gz文件的所有者变更为tom</p><h4 id="文件-目录所在组"><a href="#文件-目录所在组" class="headerlink" title="文件/目录所在组"></a>文件/目录所在组</h4><p>文件创建者所在的组是文件的所有组</p><h5 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h5><p><strong>chgrp  组名  文件名：修改文件所在组</strong></p><p>chgrp   superman   a.tar.gz：将a.tar.gz的所在组变更为superman</p><h4 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h4><p>除了文件的所有者在的组的用户外，其他用户都是其他组</p><h4 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h4><p><strong>usermod   -g   组名    用户名：将用户所在组改变</strong></p><p>usermod   -g   金刚狼   天启：将金刚狼放到天启组下</p><p>usermod   -d   目录名   用户名：改变用户登录的初始目录</p><p>usermod   -d   /var    金刚狼：将金刚狼登录目录变更为/var</p><h3 id="权限基本介绍"><a href="#权限基本介绍" class="headerlink" title="权限基本介绍"></a>权限基本介绍</h3><p>下图显示的内容，划横线的是操作权限，出了最后的点，一共十个位置(没解释的一律不知道)</p><ol><li>第0位是文件类型（d:目录，-:文件，l:软连接，c，b）</li><li>第1-3位是文件所有者的权限（r:读权限，w:写权限，x:执行权限）–&gt;user</li><li>第4-6位是文件所属组的权限–&gt;group</li><li>第7-9位是其他组的权限–&gt;other</li></ol><p><img src="https://img-blog.csdnimg.cn/2019102121461655.png" alt></p><h4 id="rwx的权限解读"><a href="#rwx的权限解读" class="headerlink" title="rwx的权限解读"></a>rwx的权限解读</h4><h5 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h5><ol><li>r（read）：读写查看权限</li><li>w（write）：修改权限，不一定可删除，需持有文件所在目录的w权限，才能删除</li><li>x（execute）：执行权限</li></ol><h5 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h5><ol><li>r（read）：读写查看权限</li><li>w（write）：修改权限，目录内容创建，修改，冲命令</li><li>x（execute）：执行全新，进入该目录</li></ol><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>可通过chmod来修改文件或目录的权限</p><h4 id="通俗方式"><a href="#通俗方式" class="headerlink" title="通俗方式"></a>通俗方式</h4><p>u：所有者，g：所有组，o：其他组，a：全部人（u和g和o的总和）</p><ol><li>chmod   u=rwx,g=rx,o=x  文件或目录：修改文件或目录使u拥有rwx，g拥有rx，o拥有x权限</li><li>chmod   o+w    文件目录名：为o添加上w权限</li><li>chmod   a-x    文件目录名：为a减去x权限</li></ol><h4 id="简易方式"><a href="#简易方式" class="headerlink" title="简易方式"></a>简易方式</h4><p>通过数字变更权限</p><p>r=4，w=2，x=1        rwx=7</p><p>chmod   u=rwx,g=rx,o=x等价于 chmod   751   文件目录名</p><h3 id="修改文件持有者"><a href="#修改文件持有者" class="headerlink" title="修改文件持有者"></a>修改文件持有者</h3><p>使用命令chown来实现</p><p><strong>chown   新的持有者    文件或目录：改变文件持有者</strong></p><p>chown   金刚狼   a.tar.gz：将a.tar.gz持有者变更为金刚狼</p><p><strong>chown    持有者:持有组   文件或目录：改变文件的持有者和持有组</strong></p><p>chown    金刚狼:天启   文件或目录：改变文件的持有者为金刚狼持有组为天启</p><p><strong>chown  -R  持有者:持有组   目录：改变目录及目录下所有文件的持有者和持有组</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;权限管理&quot;&gt;&lt;a href=&quot;#权限管理&quot; class=&quot;headerlink&quot; title=&quot;权限管理&quot;&gt;&lt;/a&gt;权限管理&lt;/h2&gt;&lt;h3 id=&quot;文件目录基本操作&quot;&gt;&lt;a href=&quot;#文件目录基本操作&quot; class=&quot;headerlink&quot; title=&quot;文件目录基本操作&quot;&gt;&lt;/a&gt;文件目录基本操作&lt;/h3&gt;&lt;h4 id=&quot;文件-目录所有者&quot;&gt;&lt;a href=&quot;#文件-目录所有者&quot; class=&quot;headerlink&quot; title=&quot;文件/目录所有者&quot;&gt;&lt;/a&gt;文件/目录所有者&lt;/h4&gt;&lt;p&gt;默认文件的创建者是文件所有者&lt;/p&gt;
&lt;h5 id=&quot;查看文件的所有者&quot;&gt;&lt;a href=&quot;#查看文件的所有者&quot; class=&quot;headerlink&quot; title=&quot;查看文件的所有者&quot;&gt;&lt;/a&gt;查看文件的所有者&lt;/h5&gt;&lt;p&gt;ls -ahl：查看文件所有者&lt;/p&gt;
&lt;p&gt;下图所示：红线是文件所有者，蓝线是文件所有组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191021214545157.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="后台" scheme="http://zzzzzzyn.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="笔记" scheme="http://zzzzzzyn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="http://zzzzzzyn.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="http://zzzzzzyn.github.io/2019/10/20/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://zzzzzzyn.github.io/2019/10/20/linux常用命令/</id>
    <published>2019-10-20T09:37:47.000Z</published>
    <updated>2019-10-23T13:53:56.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>vi和vim的三种常见模式</p><ul><li>命令模式（可以使用快捷键）</li><li>输入模式（输入<strong>i</strong>进入输入模式）</li><li>底线模式（读取，存盘，替换，离开vim）<ul><li>q：直接退出</li><li>q！：强制退出</li><li>w：写入磁盘</li><li>w！：强制写入磁盘</li><li>wq：写入磁盘并退出</li><li>wq！：强制写入磁盘并退出</li><li><a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">更多命令</a></li></ul></li></ul><a id="more"></a><img src="https://img-blog.csdnimg.cn/20191020173219893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF" style="zoom: 80%;"><h3 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h3><p><strong>shutdown：</strong></p><ul><li>shutdown -h now：立即关机</li><li>shutdown -h 1：1分钟之后关机</li><li>shutdown -r now：重启</li></ul><p><strong>halt：</strong>关机</p><p><strong>reboot：</strong>重启</p><p><strong>sync：</strong>把内存数据同步到磁盘（<strong>关机或重启是应先执行此命令</strong>）</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>linux通过组的概念来管理用户和权限，每个用户都至少属于一个组</p><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>useradd 用户名：家目录位于/home下</p><p>useradd -d /home/person ：创建用户并指定该用户的家目录</p><p>useradd -g 组名 用户名：创建用户并指定用户组（组必须存在）</p><p>usermod -g 组名 用户名：修改用户的组 </p><p><strong>passwd 用户名：设置用户的密码</strong></p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>userdel 用户名：删除用户，但保留用户家目录</p><p>userdel -r 用户名：删除用户，且删除用户家目录</p><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><p>id 用户名：显示用户id，组id，组名</p><h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p>su 用户名：切换到用户</p><p><strong>高权限用户切换低权限用户不需要输密码，低权限切换到高权限需要密码，当需要返回原来用户是使用exit命令</strong></p><h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><p>相当于角色，可对有共性的用户集中管理</p><h4 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h4><p>groupadd 组名 </p><h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><p>groupdel 组名</p><h3 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h3><p>/etc/passwd 文件：用户的配置文件，记录用户各种信息</p><p>每行含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录shell</p><p>个人感觉可以用此文件查看谁对本机进行了何种操作</p><p>/etc/shadow 文件：口令文件</p><p>/etc/group 文件：组配置文件</p><p>每行含义：组名：口令：组标识号：组内用户列表</p><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><h4 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h4><ul><li><p>man [命令或配置文件]：帮助指令，会列出帮助信息（centos7支持简体中文）</p></li><li><p>help [命令]：帮助指令</p></li></ul><h4 id="文件目录类-常用"><a href="#文件目录类-常用" class="headerlink" title="文件目录类(常用)"></a>文件目录类(常用)</h4><ul><li><p>pwd：显示当前目录的绝对路径</p></li><li><p>ls：显示文件和目录</p><ul><li>ls -a：显示当前目录所有的文件和目录</li><li>ls -l：列表方式显示信息</li></ul></li><li><p>cd：进入到指定目录</p><ul><li>cd ~ :回到自己的家目录</li><li>cd .. ：回到当前目录的上级目录（相对定位）</li><li>cd /usr/local：进入到/usr目录下的local目录（绝对定位）</li></ul></li><li><p>mkdir：创建目录文件夹</p><ul><li>mkdir /home/dog：在home下创建dog目录</li><li>mkdir -p /home/animal/dog：在home先创建animal然后在animal下创建dog</li></ul></li><li><p>rmdir：删除空目录</p><ul><li>rmdir /home/dog</li></ul></li><li><p><strong>rm  -rf  目录名或文件名：强制删除文件夹及文件夹下所有文件（删库跑路必备神器）</strong></p></li><li><p>touch 文件名：创建一个空文件</p></li><li><p><strong>cp：拷贝文件到指定目录</strong></p><ul><li><p>cp aaa.txt bbb/：将当前目录aaa.txt拷贝到bbb目录下</p></li><li><p>cp -r /home/tomcat/   /opt/：将home下的tomcat目录拷贝到opt目录下，当tomat有文件或文件夹时，应带参数-r</p></li><li><p>\cp -r /home/tomcat/  /opt/：opt下存在tomcat目录时会提示是否覆盖，此命令强制覆盖</p></li></ul></li><li><p>mv：移动文件与目录或重命名</p><ul><li>mv  pig.txt   dog.txt：将pig.txt重命名为dog.txt</li><li>mv   tomcat/    /home/：将tomcat目录移动到home目录下</li></ul></li><li><p><strong>cat：只读方式打开文件</strong></p><ul><li><strong>cat  文件名：显示文件内容</strong></li><li><strong>cat  -n   文件名：带行号，显示文件内容</strong></li><li><strong>cat  -n    文件名   |   more ：带行号，分页(空格进入下一页)，显示文件内容</strong></li></ul></li><li><p><strong>less：分屏查看内容(懒加载，效率高，适合大型文件的查看)</strong></p><ul><li><p>less  /etc/profile</p><table><thead><tr><th align="left">快捷键</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">空格键、pagedown</td><td align="left">向下翻动一页</td></tr><tr><td align="left">pageup</td><td align="left">向上翻动一页</td></tr><tr><td align="left">/字符</td><td align="left">向下搜索字符</td></tr><tr><td align="left">?字符</td><td align="left">向上搜索字符</td></tr><tr><td align="left">q</td><td align="left">离开less程序</td></tr></tbody></table></li></ul></li><li><p><strong>&gt;</strong>和<strong>&gt;&gt;</strong></p><ul><li><strong>cat /etc/profile &gt; a.txt：将etc下的peofile内容覆盖写入到a.txt中</strong></li><li><strong>cat /etc/profile &gt;&gt; a.txt：将etc下的peofile内容追加写入到a.txt中</strong></li><li><strong>echo hello  &gt;&gt;  a.txt：将hello追加写入到a.txt中</strong></li><li><strong>echo hello：将hello输出到控制台</strong></li></ul></li><li><p>head  文件名(默认前10行)</p><ul><li>head  /etc/profile：显示etc下profile<strong>前10行</strong>内容</li><li>head  -n   5  /etc/profile：显示etc下profile<strong>前5行</strong>内容</li></ul></li><li><p>tail  文件名(默认输出后10行)</p><ul><li><p>tail  /etc/profile：显示etc下profile<strong>后10行</strong>内容</p></li><li><p>tail   -n   5  /etc/profile：显示etc下profile<strong>后5行</strong>内容</p></li><li><p><strong>tail   -f   文件名：实时追踪文件的所有更新(常用，日志文件的追踪)</strong></p></li></ul></li><li><p>ln  -s  链接到的地址    链接名(类似于windows的快捷方式)</p><ul><li>ln   -s    /root     lindToRoot：链接为lindToRoot</li></ul></li><li><p>history：查看执行过的历史指令</p></li></ul><h4 id="时间日历类"><a href="#时间日历类" class="headerlink" title="时间日历类"></a>时间日历类</h4><ul><li><p>date：当前时间信息，设置时间</p><ul><li><p>date   +%Y：当前年份</p></li><li><p>date   +%Y-%m：当前年月</p></li><li><p>date   +%Y-%m-%d：当前年月日</p></li><li><p>date   “+%Y-%m-%d %H:%M:%S””：当前年月日时分秒</p></li><li><p>date -s “2019-10-19”：设置日期</p></li></ul></li><li><p>cal：日历</p><ul><li>cal ：显示当前日历信息</li><li>cal   2019：显示2019年所有日历</li></ul></li></ul><h4 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h4><ul><li><p>gzip和gunzip：压缩和解压缩(完成后不会保留原文件)</p><ul><li>gzip  a.txt：将a.txt压缩，并删除掉a.txt</li><li>gunzip  a.txt.gz：将a.txt.gz解压缩，并删除掉a.txt.gz</li></ul></li><li><p>zip和unzip：压缩和解压缩</p><ul><li>zip  [选项]    压缩包.zip    被压缩的文件或目录</li><li>zip   -r(递归压缩)    package.zip     /home/：将home下的所有文件递归压缩为package.zip    </li><li>unzip   [选项]  [解压位置]     被解压文件或目录</li><li>unzip   -d(指定解压位置)   /opt/tmp/    package.zip：将package解压到opt目录的tmp目录下</li></ul></li><li><p><strong>tar：压缩和解压缩指令，打包完的文件是.tag.gz文件</strong></p><ul><li><p>tar   [选项]   xxx.tar.gz    被打包的文件或目录</p></li><li><p>tar -zcvf a.tar.gz a.txt b.txt：将a.txt和b.txt压缩为a.tar.gz</p></li><li><p>tar -zcvf a.tar.gz /home/：将home目录下所有文件压缩为a.tar.gz</p></li><li><p>tar -zxvf a.tar.gz -C /opt：将a.tar.gz解压缩到opt目录下</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr></tbody></table></li></ul></li></ul><h3 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h3><h4 id="显示系统进程"><a href="#显示系统进程" class="headerlink" title="显示系统进程"></a>显示系统进程</h4><p>ps，进程查看指令，通常使用参数为ps  -aux</p><table><thead><tr><th align="left">-a</th><th align="center">显示终端所有进程信息</th></tr></thead><tbody><tr><td align="left"><strong>-u</strong></td><td align="center"><strong>用户格式显示进程信息</strong></td></tr><tr><td align="left"><strong>-x</strong></td><td align="center"><strong>显示后台进程运行参数</strong></td></tr></tbody></table><p>ps   -aux  |   more：分页查看进程</p><p>ps   -ef   |   more：分页全格式显示当前进程</p><p><strong>ps   -f   |   grep mysql：查看mysql相关进程</strong></p><table><thead><tr><th>-e</th><th align="center">显示所有进程</th></tr></thead><tbody><tr><td><strong>-f</strong></td><td align="center"><strong>全格式</strong></td></tr></tbody></table><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>kill   -9(强制杀死)    进程号：通过进程号强制杀死进程</p><p><strong>kill   -9   9527：强制杀死进程号为9527的进程</strong></p><p>killall    父进程名：杀掉父进程及下属所有子进程</p><h4 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h4><p>本质是进程，运行在后台，监听端口，又称守护进程（例如：mysql，sshd，防火墙）</p><p><strong>systemctl [start | stop | restart | reload | status]  服务名</strong></p><p>systemctl status firewalld：查看防火墙状态</p><h3 id="rpm和yum"><a href="#rpm和yum" class="headerlink" title="rpm和yum"></a>rpm和yum</h3><h4 id="rpm包删除"><a href="#rpm包删除" class="headerlink" title="rpm包删除"></a>rpm包删除</h4><p><strong>rpm -e  rpm包名称</strong></p><p>rpm  -e  firefox：卸载火狐</p><h4 id="rpm包安装"><a href="#rpm包安装" class="headerlink" title="rpm包安装"></a>rpm包安装</h4><p>rmp  -ivh(i:安装，v:提示信息，h:进度条)  rmp包全路径名称</p><h4 id="yum相关文件查询"><a href="#yum相关文件查询" class="headerlink" title="yum相关文件查询"></a>yum相关文件查询</h4><p>yum   list   |  grep   文件：查询yum服务器是否有需要安装的软件</p><p>yum   list   |   grep  chrome：查询谷歌浏览器</p><h4 id="安装yum指定包"><a href="#安装yum指定包" class="headerlink" title="安装yum指定包"></a>安装yum指定包</h4><p><strong>yum  install   文件名：下载安装文件</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vim&quot;&gt;&lt;a href=&quot;#vim&quot; class=&quot;headerlink&quot; title=&quot;vim&quot;&gt;&lt;/a&gt;vim&lt;/h3&gt;&lt;p&gt;vi和vim的三种常见模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令模式（可以使用快捷键）&lt;/li&gt;
&lt;li&gt;输入模式（输入&lt;strong&gt;i&lt;/strong&gt;进入输入模式）&lt;/li&gt;
&lt;li&gt;底线模式（读取，存盘，替换，离开vim）&lt;ul&gt;
&lt;li&gt;q：直接退出&lt;/li&gt;
&lt;li&gt;q！：强制退出&lt;/li&gt;
&lt;li&gt;w：写入磁盘&lt;/li&gt;
&lt;li&gt;w！：强制写入磁盘&lt;/li&gt;
&lt;li&gt;wq：写入磁盘并退出&lt;/li&gt;
&lt;li&gt;wq！：强制写入磁盘并退出&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/linux/linux-vim.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;更多命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="后台" scheme="http://zzzzzzyn.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="笔记" scheme="http://zzzzzzyn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="http://zzzzzzyn.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
